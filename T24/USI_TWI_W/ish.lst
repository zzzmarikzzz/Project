gavrasm Gerd's AVR assembler version 3.4 (C)2014 by DG4FAC
----------------------------------------------------------
Source file: ish.asm
Hex file:    ish.hex
Eeprom file: ish.eep
Compiled:    02.02.2015, 02:08:46
Pass:        2
     1: .include "/home/marik/Project/tn24Adef.inc"
  Including file /home/marik/Project/tn24Adef.inc
     1: ;***** THIS IS A MACHINE GENERATED FILE - DO NOT EDIT ********************
     2: ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny24A.xml ***********
     3: ;*************************************************************************
     4: ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
     5: ;* 
     6: ;* Number            : AVR000
     7: ;* File Name         : "tn24Adef.inc"
     8: ;* Title             : Register/Bit Definitions for the ATtiny24A
     9: ;* Date              : 2011-02-09
    10: ;* Version           : 2.35
    11: ;* Support E-mail    : avr@atmel.com
    12: ;* Target MCU        : ATtiny24A
    13: ;* 
    14: ;* DESCRIPTION
    15: ;* When including this file in the assembly program file, all I/O register 
    16: ;* names and I/O register bit names appearing in the data book can be used.
    17: ;* In addition, the six registers forming the three data pointers X, Y and 
    18: ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
    19: ;* SRAM is also defined 
    20: ;* 
    21: ;* The Register names are represented by their hexadecimal address.
    22: ;* 
    23: ;* The Register Bit names are represented by their bit number (0-7).
    24: ;* 
    25: ;* Please observe the difference in using the bit names with instructions
    26: ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
    27: ;* (skip if bit in register set/cleared). The following example illustrates
    28: ;* this:
    29: ;* 
    30: ;* in    r16,PORTB             ;read PORTB latch
    31: ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
    32: ;* out   PORTB,r16             ;output to PORTB
    33: ;* 
    34: ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
    35: ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
    36: ;* rjmp  TOV0_is_set           ;jump if set
    37: ;* ...                         ;otherwise do something else
    38: ;*************************************************************************
    39: 
    40: #ifndef _TN24ADEF_INC_
    41: #define _TN24ADEF_INC_
    42: 
    43: 
    44: #pragma partinc 0
    45: 
    46: ; ***** SPECIFY DEVICE ***************************************************
    47: .device ATtiny24A
    48: #pragma AVRPART ADMIN PART_NAME ATtiny24A
    49: .equ	SIGNATURE_000	= 0x1e
    50: .equ	SIGNATURE_001	= 0x91
    51: .equ	SIGNATURE_002	= 0x0b
    52: 
    53: #pragma AVRPART CORE CORE_VERSION V2
    54: #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
    55: 
    56: 
    57: ; ***** I/O REGISTER DEFINITIONS *****************************************
    58: ; NOTE:
    59: ; Definitions marked "MEMORY MAPPED"are extended I/O ports
    60: ; and cannot be used with IN/OUT instructions
    61: .equ	SREG	= 0x3f
    62: .equ	SPL	= 0x3d
    63: .equ	OCR0B	= 0x3c
    64: .equ	GIMSK	= 0x3b
    65: .equ	GIFR	= 0x3a
    66: .equ	TIMSK0	= 0x39
    67: .equ	TIFR0	= 0x38
    68: .equ	SPMCSR	= 0x37
    69: .equ	OCR0A	= 0x36
    70: .equ	MCUCR	= 0x35
    71: .equ	MCUSR	= 0x34
    72: .equ	TCCR0B	= 0x33
    73: .equ	TCNT0	= 0x32
    74: .equ	OSCCAL	= 0x31
    75: .equ	TCCR0A	= 0x30
    76: .equ	TCCR1A	= 0x2f
    77: .equ	TCCR1B	= 0x2e
    78: .equ	TCNT1L	= 0x2c
    79: .equ	TCNT1H	= 0x2d
    80: .equ	OCR1AL	= 0x2a
    81: .equ	OCR1AH	= 0x2b
    82: .equ	OCR1BL	= 0x28
    83: .equ	OCR1BH	= 0x29
    84: .equ	DWDR	= 0x27
    85: .equ	CLKPR	= 0x26
    86: .equ	ICR1L	= 0x24
    87: .equ	ICR1H	= 0x25
    88: .equ	GTCCR	= 0x23
    89: .equ	TCCR1C	= 0x22
    90: .equ	WDTCSR	= 0x21
    91: .equ	PCMSK1	= 0x20
    92: .equ	EEARH	= 0x1f
    93: .equ	EEARL	= 0x1e
    94: .equ	EEDR	= 0x1d
    95: .equ	EECR	= 0x1c
    96: .equ	PORTA	= 0x1b
    97: .equ	DDRA	= 0x1a
    98: .equ	PINA	= 0x19
    99: .equ	PORTB	= 0x18
   100: .equ	DDRB	= 0x17
   101: .equ	PINB	= 0x16
   102: .equ	GPIOR2	= 0x15
   103: .equ	GPIOR1	= 0x14
   104: .equ	GPIOR0	= 0x13
   105: .equ	PCMSK0	= 0x12
   106: .equ	USIBR	= 0x10
   107: .equ	USIDR	= 0x0f
   108: .equ	USISR	= 0x0e
   109: .equ	USICR	= 0x0d
   110: .equ	TIMSK1	= 0x0c
   111: .equ	TIFR1	= 0x0b
   112: .equ	ACSR	= 0x08
   113: .equ	ADMUX	= 0x07
   114: .equ	ADCSRA	= 0x06
   115: .equ	ADCH	= 0x05
   116: .equ	ADCL	= 0x04
   117: .equ	ADCSRB	= 0x03
   118: .equ	DIDR0	= 0x01
   119: .equ	PRR	= 0x00
   120: 
   121: 
   122: ; ***** BIT DEFINITIONS **************************************************
   123: 
   124: ; ***** PORTA ************************
   125: ; PORTA - Port A Data Register
   126: .equ	PORTA0	= 0	; Port A Data Register bit 0
   127: .equ	PA0	= 0	; For compatibility
   128: .equ	PORTA1	= 1	; Port A Data Register bit 1
   129: .equ	PA1	= 1	; For compatibility
   130: .equ	PORTA2	= 2	; Port A Data Register bit 2
   131: .equ	PA2	= 2	; For compatibility
   132: .equ	PORTA3	= 3	; Port A Data Register bit 3
   133: .equ	PA3	= 3	; For compatibility
   134: .equ	PORTA4	= 4	; Port A Data Register bit 4
   135: .equ	PA4	= 4	; For compatibility
   136: .equ	PORTA5	= 5	; Port A Data Register bit 5
   137: .equ	PA5	= 5	; For compatibility
   138: .equ	PORTA6	= 6	; Port A Data Register bit 6
   139: .equ	PA6	= 6	; For compatibility
   140: .equ	PORTA7	= 7	; Port A Data Register bit 7
   141: .equ	PA7	= 7	; For compatibility
   142: 
   143: ; DDRA - Port A Data Direction Register
   144: .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
   145: .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
   146: .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
   147: .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
   148: .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
   149: .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
   150: .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
   151: .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
   152: 
   153: ; PINA - Port A Input Pins
   154: .equ	PINA0	= 0	; Input Pins, Port A bit 0
   155: .equ	PINA1	= 1	; Input Pins, Port A bit 1
   156: .equ	PINA2	= 2	; Input Pins, Port A bit 2
   157: .equ	PINA3	= 3	; Input Pins, Port A bit 3
   158: .equ	PINA4	= 4	; Input Pins, Port A bit 4
   159: .equ	PINA5	= 5	; Input Pins, Port A bit 5
   160: .equ	PINA6	= 6	; Input Pins, Port A bit 6
   161: .equ	PINA7	= 7	; Input Pins, Port A bit 7
   162: 
   163: 
   164: ; ***** PORTB ************************
   165: ; PORTB - Data Register, Port B
   166: .equ	PORTB0	= 0	; 
   167: .equ	PB0	= 0	; For compatibility
   168: .equ	PORTB1	= 1	; 
   169: .equ	PB1	= 1	; For compatibility
   170: .equ	PORTB2	= 2	; 
   171: .equ	PB2	= 2	; For compatibility
   172: .equ	PORTB3	= 3	; 
   173: .equ	PB3	= 3	; For compatibility
   174: 
   175: ; DDRB - Data Direction Register, Port B
   176: .equ	DDB0	= 0	; 
   177: .equ	DDB1	= 1	; 
   178: .equ	DDB2	= 2	; 
   179: .equ	DDB3	= 3	; 
   180: 
   181: ; PINB - Input Pins, Port B
   182: .equ	PINB0	= 0	; 
   183: .equ	PINB1	= 1	; 
   184: .equ	PINB2	= 2	; 
   185: .equ	PINB3	= 3	; 
   186: 
   187: 
   188: ; ***** ANALOG_COMPARATOR ************
   189: ; ADCSRB - ADC Control and Status Register B
   190: .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
   191: 
   192: ; ACSR - Analog Comparator Control And Status Register
   193: .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
   194: .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
   195: .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
   196: .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
   197: .equ	ACI	= 4	; Analog Comparator Interrupt Flag
   198: .equ	ACO	= 5	; Analog Compare Output
   199: .equ	ACBG	= 6	; Analog Comparator Bandgap Select
   200: .equ	AINBG	= ACBG	; For compatibility
   201: .equ	ACD	= 7	; Analog Comparator Disable
   202: 
   203: ; DIDR0 - 
   204: .equ	ADC0D	= 0	; ADC 0 Digital input buffer disable
   205: .equ	ADC1D	= 1	; ADC 1 Digital input buffer disable
   206: 
   207: 
   208: ; ***** AD_CONVERTER *****************
   209: ; ADMUX - ADC Multiplexer Selection Register
   210: .equ	MUX0	= 0	; Analog Channel and Gain Selection Bit 0
   211: .equ	MUX1	= 1	; Analog Channel and Gain Selection Bit 1
   212: .equ	MUX2	= 2	; Analog Channel and Gain Selection Bit 2
   213: .equ	MUX3	= 3	; Analog Channel and Gain Selection Bit 3
   214: .equ	MUX4	= 4	; Analog Channel and Gain Selection Bit 4
   215: .equ	MUX5	= 5	; Analog Channel and Gain Selection Bit 5
   216: .equ	REFS0	= 6	; Reference Selection Bit 0
   217: .equ	REFS1	= 7	; Reference Selection Bit 1
   218: 
   219: ; ADCSRA - ADC Control and Status Register A
   220: .equ	ADPS0	= 0	; ADC  Prescaler Select Bit 0
   221: .equ	ADPS1	= 1	; ADC  Prescaler Select Bit 1
   222: .equ	ADPS2	= 2	; ADC  Prescaler Select Bit 2
   223: .equ	ADIE	= 3	; ADC Interrupt Enable
   224: .equ	ADIF	= 4	; ADC Interrupt Flag
   225: .equ	ADATE	= 5	; ADC Auto Trigger Enable
   226: .equ	ADSC	= 6	; ADC Start Conversion
   227: .equ	ADEN	= 7	; ADC Enable
   228: 
   229: ; ADCH - ADC Data Register High Byte
   230: .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
   231: .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
   232: .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
   233: .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
   234: .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
   235: .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
   236: .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
   237: .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
   238: 
   239: ; ADCL - ADC Data Register Low Byte
   240: .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
   241: .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
   242: .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
   243: .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
   244: .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
   245: .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
   246: .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
   247: .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
   248: 
   249: ; ADCSRB - ADC Control and Status Register B
   250: .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
   251: .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
   252: .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
   253: .equ	ADLAR	= 4	; ADC Left Adjust Result
   254: .equ	BIN	= 7	; Bipolar Input Mode
   255: 
   256: ; DIDR0 - Digital Input Disable Register 0
   257: ;.equ	ADC0D	= 0	; ADC0 Digital Input Disable
   258: ;.equ	ADC1D	= 1	; ADC1 Digital Input Disable
   259: .equ	ADC2D	= 2	; ADC2 Digital Input Disable
   260: .equ	ADC3D	= 3	; ADC3 Digital Input Disable
   261: .equ	ADC4D	= 4	; ADC4 Digital Input Disable
   262: .equ	ADC5D	= 5	; ADC5 Digital Input Disable
   263: .equ	ADC6D	= 6	; ADC6 Digital Input Disable
   264: .equ	ADC7D	= 7	; ADC7 Digital Input Disable
   265: 
   266: 
   267: ; ***** USI **************************
   268: ; USIBR - USI Buffer Register
   269: .equ	USIBR0	= 0	; USI Buffer Register bit 0
   270: .equ	USIBR1	= 1	; USI Buffer Register bit 1
   271: .equ	USIBR2	= 2	; USI Buffer Register bit 2
   272: .equ	USIBR3	= 3	; USI Buffer Register bit 3
   273: .equ	USIBR4	= 4	; USI Buffer Register bit 4
   274: .equ	USIBR5	= 5	; USI Buffer Register bit 5
   275: .equ	USIBR6	= 6	; USI Buffer Register bit 6
   276: .equ	USIBR7	= 7	; USI Buffer Register bit 7
   277: 
   278: ; USIDR - USI Data Register
   279: .equ	USIDR0	= 0	; USI Data Register bit 0
   280: .equ	USIDR1	= 1	; USI Data Register bit 1
   281: .equ	USIDR2	= 2	; USI Data Register bit 2
   282: .equ	USIDR3	= 3	; USI Data Register bit 3
   283: .equ	USIDR4	= 4	; USI Data Register bit 4
   284: .equ	USIDR5	= 5	; USI Data Register bit 5
   285: .equ	USIDR6	= 6	; USI Data Register bit 6
   286: .equ	USIDR7	= 7	; USI Data Register bit 7
   287: 
   288: ; USISR - USI Status Register
   289: .equ	USICNT0	= 0	; USI Counter Value Bit 0
   290: .equ	USICNT1	= 1	; USI Counter Value Bit 1
   291: .equ	USICNT2	= 2	; USI Counter Value Bit 2
   292: .equ	USICNT3	= 3	; USI Counter Value Bit 3
   293: .equ	USIDC	= 4	; Data Output Collision
   294: .equ	USIPF	= 5	; Stop Condition Flag
   295: .equ	USIOIF	= 6	; Counter Overflow Interrupt Flag
   296: .equ	USISIF	= 7	; Start Condition Interrupt Flag
   297: 
   298: ; USICR - USI Control Register
   299: .equ	USITC	= 0	; Toggle Clock Port Pin
   300: .equ	USICLK	= 1	; Clock Strobe
   301: .equ	USICS0	= 2	; USI Clock Source Select Bit 0
   302: .equ	USICS1	= 3	; USI Clock Source Select Bit 1
   303: .equ	USIWM0	= 4	; USI Wire Mode Bit 0
   304: .equ	USIWM1	= 5	; USI Wire Mode Bit 1
   305: .equ	USIOIE	= 6	; Counter Overflow Interrupt Enable
   306: .equ	USISIE	= 7	; Start Condition Interrupt Enable
   307: 
   308: 
   309: ; ***** EXTERNAL_INTERRUPT ***********
   310: ; MCUCR - MCU Control Register
   311: .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
   312: .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
   313: 
   314: ; GIMSK - General Interrupt Mask Register
   315: .equ	GICR	= GIMSK	; For compatibility
   316: .equ	PCIE0	= 4	; Pin Change Interrupt Enable 0
   317: .equ	PCIE1	= 5	; Pin Change Interrupt Enable 1
   318: .equ	INT0	= 6	; External Interrupt Request 0 Enable
   319: 
   320: ; GIFR - General Interrupt Flag register
   321: .equ	PCIF0	= 4	; Pin Change Interrupt Flag 0
   322: .equ	PCIF1	= 5	; Pin Change Interrupt Flag 1
   323: .equ	INTF0	= 6	; External Interrupt Flag 0
   324: 
   325: ; PCMSK1 - Pin Change Enable Mask 1
   326: .equ	PCINT8	= 0	; Pin Change Enable Mask Bit 8
   327: .equ	PCINT9	= 1	; Pin Change Enable Mask Bit 9
   328: .equ	PCINT10	= 2	; Pin Change Enable Mask Bit 10
   329: .equ	PCINT11	= 3	; Pin Change Enable Mask Bit 11
   330: 
   331: ; PCMSK0 - Pin Change Enable Mask 0
   332: .equ	PCINT0	= 0	; Pin Change Enable Mask Bit 0
   333: .equ	PCINT1	= 1	; Pin Change Enable Mask Bit 1
   334: .equ	PCINT2	= 2	; Pin Change Enable Mask Bit 2
   335: .equ	PCINT3	= 3	; Pin Change Enable Mask Bit 3
   336: .equ	PCINT4	= 4	; Pin Change Enable Mask Bit 4
   337: .equ	PCINT5	= 5	; Pin Change Enable Mask Bit 5
   338: .equ	PCINT6	= 6	; Pin Change Enable Mask Bit 6
   339: .equ	PCINT7	= 7	; Pin Change Enable Mask Bit 7
   340: 
   341: 
   342: ; ***** EEPROM ***********************
   343: ; EEARL - EEPROM Address Register Low Byte
   344: .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
   345: .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
   346: .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
   347: .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
   348: .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
   349: .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
   350: .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
   351: .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
   352: 
   353: ; EEARH - EEPROM Address Register High Byte
   354: .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 0
   355: 
   356: ; EEDR - EEPROM Data Register
   357: .equ	EEDR0	= 0	; EEPROM Data Register bit 0
   358: .equ	EEDR1	= 1	; EEPROM Data Register bit 1
   359: .equ	EEDR2	= 2	; EEPROM Data Register bit 2
   360: .equ	EEDR3	= 3	; EEPROM Data Register bit 3
   361: .equ	EEDR4	= 4	; EEPROM Data Register bit 4
   362: .equ	EEDR5	= 5	; EEPROM Data Register bit 5
   363: .equ	EEDR6	= 6	; EEPROM Data Register bit 6
   364: .equ	EEDR7	= 7	; EEPROM Data Register bit 7
   365: 
   366: ; EECR - EEPROM Control Register
   367: .equ	EERE	= 0	; EEPROM Read Enable
   368: .equ	EEPE	= 1	; EEPROM Write Enable
   369: .equ	EEMPE	= 2	; EEPROM Master Write Enable
   370: .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
   371: .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
   372: .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
   373: 
   374: 
   375: ; ***** WATCHDOG *********************
   376: ; WDTCSR - Watchdog Timer Control Register
   377: .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
   378: .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
   379: .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
   380: .equ	WDE	= 3	; Watch Dog Enable
   381: .equ	WDCE	= 4	; Watchdog Change Enable
   382: .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
   383: .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
   384: .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
   385: 
   386: 
   387: ; ***** TIMER_COUNTER_0 **************
   388: ; TIMSK0 - Timer/Counter Interrupt Mask Register
   389: .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
   390: .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
   391: .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
   392: 
   393: ; TIFR0 - Timer/Counter0 Interrupt Flag Register
   394: .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
   395: .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag A
   396: .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag B
   397: 
   398: ; TCCR0A - Timer/Counter  Control Register A
   399: .equ	WGM00	= 0	; Waveform Generation Mode bit 0
   400: .equ	WGM01	= 1	; Waveform Generation Mode bit 1
   401: .equ	COM0B0	= 4	; Compare Match Output B Mode bit 0
   402: .equ	COM0B1	= 5	; Compare Match Output B Mode bit 1
   403: .equ	COM0A0	= 6	; Compare Match Output A Mode bit 0
   404: .equ	COM0A1	= 7	; Compare Match Output A Mode bit 1
   405: 
   406: ; TCCR0B - Timer/Counter Control Register B
   407: .equ	CS00	= 0	; Clock Select bit 0
   408: .equ	CS01	= 1	; Clock Select bit 1
   409: .equ	CS02	= 2	; Clock Select bit 2
   410: .equ	WGM02	= 3	; Waveform Generation Mode bit 2
   411: .equ	FOC0B	= 6	; Force Output Compare B
   412: .equ	FOC0A	= 7	; Force Output Compare A
   413: 
   414: ; TCNT0 - Timer/Counter0
   415: .equ	TCNT0_0	= 0	; 
   416: .equ	TCNT0_1	= 1	; 
   417: .equ	TCNT0_2	= 2	; 
   418: .equ	TCNT0_3	= 3	; 
   419: .equ	TCNT0_4	= 4	; 
   420: .equ	TCNT0_5	= 5	; 
   421: .equ	TCNT0_6	= 6	; 
   422: .equ	TCNT0_7	= 7	; 
   423: 
   424: ; OCR0A - Timer/Counter0 Output Compare Register A
   425: .equ	OCR0A_0	= 0	; 
   426: .equ	OCR0A_1	= 1	; 
   427: .equ	OCR0A_2	= 2	; 
   428: .equ	OCR0A_3	= 3	; 
   429: .equ	OCR0A_4	= 4	; 
   430: .equ	OCR0A_5	= 5	; 
   431: .equ	OCR0A_6	= 6	; 
   432: .equ	OCR0A_7	= 7	; 
   433: 
   434: ; OCR0B - Timer/Counter0 Output Compare Register B
   435: .equ	OCR0_0	= 0	; 
   436: .equ	OCR0_1	= 1	; 
   437: .equ	OCR0_2	= 2	; 
   438: .equ	OCR0_3	= 3	; 
   439: .equ	OCR0_4	= 4	; 
   440: .equ	OCR0_5	= 5	; 
   441: .equ	OCR0_6	= 6	; 
   442: .equ	OCR0_7	= 7	; 
   443: 
   444: ; GTCCR - General Timer/Counter Control Register
   445: .equ	PSR10	= 0	; Prescaler Reset Timer/CounterN
   446: .equ	TSM	= 7	; Timer/Counter Synchronization Mode
   447: 
   448: 
   449: ; ***** TIMER_COUNTER_1 **************
   450: ; TIMSK1 - Timer/Counter1 Interrupt Mask Register
   451: .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
   452: .equ	OCIE1A	= 1	; Timer/Counter1 Output Compare A Match Interrupt Enable
   453: .equ	OCIE1B	= 2	; Timer/Counter1 Output Compare B Match Interrupt Enable
   454: .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
   455: 
   456: ; TIFR1 - Timer/Counter Interrupt Flag register
   457: .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
   458: .equ	OCF1A	= 1	; Timer/Counter1 Output Compare A Match Flag
   459: .equ	OCF1B	= 2	; Timer/Counter1 Output Compare B Match Flag
   460: .equ	ICF1	= 5	; Timer/Counter1 Input Capture Flag
   461: 
   462: ; TCCR1A - Timer/Counter1 Control Register A
   463: .equ	WGM10	= 0	; Pulse Width Modulator Select Bit 0
   464: .equ	PWM10	= WGM10	; For compatibility
   465: .equ	WGM11	= 1	; Pulse Width Modulator Select Bit 1
   466: .equ	PWM11	= WGM11	; For compatibility
   467: .equ	COM1B0	= 4	; Comparet Ouput Mode 1B, bit 0
   468: .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
   469: .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
   470: .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
   471: 
   472: ; TCCR1B - Timer/Counter1 Control Register B
   473: .equ	CS10	= 0	; Clock Select bit 0
   474: .equ	CS11	= 1	; Clock Select 1 bit 1
   475: .equ	CS12	= 2	; Clock Select1 bit 2
   476: .equ	WGM12	= 3	; Waveform Generation Mode Bit 2
   477: .equ	CTC1	= WGM12	; For compatibility
   478: .equ	WGM13	= 4	; Waveform Generation Mode Bit 3
   479: .equ	ICES1	= 6	; Input Capture 1 Edge Select
   480: .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
   481: 
   482: ; TCCR1C - Timer/Counter1 Control Register C
   483: .equ	FOC1B	= 6	; Force Output Compare for Channel B
   484: .equ	FOC1A	= 7	; Force Output Compare for Channel A
   485: 
   486: 
   487: ; ***** CPU **************************
   488: ; SREG - Status Register
   489: .equ	SREG_C	= 0	; Carry Flag
   490: .equ	SREG_Z	= 1	; Zero Flag
   491: .equ	SREG_N	= 2	; Negative Flag
   492: .equ	SREG_V	= 3	; Two's Complement Overflow Flag
   493: .equ	SREG_S	= 4	; Sign Bit
   494: .equ	SREG_H	= 5	; Half Carry Flag
   495: .equ	SREG_T	= 6	; Bit Copy Storage
   496: .equ	SREG_I	= 7	; Global Interrupt Enable
   497: 
   498: ; SPL - Stack Pointer Low
   499: .equ	SP0	= 0	; Stack pointer bit 0
   500: .equ	SP1	= 1	; Stack pointer bit 1
   501: .equ	SP2	= 2	; Stack pointer bit 2
   502: .equ	SP3	= 3	; Stack pointer bit 3
   503: .equ	SP4	= 4	; Stack pointer bit 4
   504: .equ	SP5	= 5	; Stack pointer bit 5
   505: .equ	SP6	= 6	; Stack pointer bit 6
   506: .equ	SP7	= 7	; Stack pointer bit 7
   507: 
   508: ; MCUCR - MCU Control Register
   509: .equ	SM0	= 3	; Sleep Mode Select Bit 0
   510: .equ	SM1	= 4	; Sleep Mode Select Bit 1
   511: .equ	SE	= 5	; Sleep Enable
   512: .equ	PUD	= 6	; 
   513: 
   514: ; MCUSR - MCU Status Register
   515: .equ	PORF	= 0	; Power-on reset flag
   516: .equ	EXTRF	= 1	; External Reset Flag
   517: .equ	BORF	= 2	; Brown-out Reset Flag
   518: .equ	WDRF	= 3	; Watchdog Reset Flag
   519: 
   520: ; OSCCAL - Oscillator Calibration Value
   521: .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
   522: .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
   523: .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
   524: .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
   525: .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
   526: .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
   527: .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
   528: .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
   529: 
   530: ; GPIOR2 - General Purpose I/O Register 2
   531: .equ	GPIOR20	= 0	; 
   532: .equ	GPIOR21	= 1	; 
   533: .equ	GPIOR22	= 2	; 
   534: .equ	GPIOR23	= 3	; 
   535: .equ	GPIOR24	= 4	; 
   536: .equ	GPIOR25	= 5	; 
   537: .equ	GPIOR26	= 6	; 
   538: .equ	GPIOR27	= 7	; 
   539: 
   540: ; GPIOR1 - General Purpose I/O Register 1
   541: .equ	GPIOR10	= 0	; 
   542: .equ	GPIOR11	= 1	; 
   543: .equ	GPIOR12	= 2	; 
   544: .equ	GPIOR13	= 3	; 
   545: .equ	GPIOR14	= 4	; 
   546: .equ	GPIOR15	= 5	; 
   547: .equ	GPIOR16	= 6	; 
   548: .equ	GPIOR17	= 7	; 
   549: 
   550: ; GPIOR0 - General Purpose I/O Register 0
   551: .equ	GPIOR00	= 0	; 
   552: .equ	GPIOR01	= 1	; 
   553: .equ	GPIOR02	= 2	; 
   554: .equ	GPIOR03	= 3	; 
   555: .equ	GPIOR04	= 4	; 
   556: .equ	GPIOR05	= 5	; 
   557: .equ	GPIOR06	= 6	; 
   558: .equ	GPIOR07	= 7	; 
   559: 
   560: ; PRR - Power Reduction Register
   561: .equ	PRADC	= 0	; Power Reduction ADC
   562: .equ	PRUSI	= 1	; Power Reduction USI
   563: .equ	PRTIM0	= 2	; Power Reduction Timer/Counter0
   564: .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
   565: 
   566: ; CLKPR - Clock Prescale Register
   567: .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
   568: .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
   569: .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
   570: .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
   571: .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
   572: 
   573: 
   574: ; ***** BOOT_LOAD ********************
   575: ; SPMCSR - Store Program Memory Control Register
   576: .equ	SPMEN	= 0	; Store Program Memory Enable
   577: .equ	PGERS	= 1	; Page Erase
   578: .equ	PGWRT	= 2	; Page Write
   579: .equ	RFLB	= 3	; Read fuse and lock bits
   580: .equ	CTPB	= 4	; Clear temporary page buffer
   581: 
   582: 
   583: 
   584: ; ***** LOCKSBITS ********************************************************
   585: .equ	LB1	= 0	; Lockbit
   586: .equ	LB2	= 1	; Lockbit
   587: 
   588: 
   589: ; ***** FUSES ************************************************************
   590: ; LOW fuse bits
   591: .equ	CKSEL0	= 0	; Select Clock source
   592: .equ	CKSEL1	= 1	; Select Clock source
   593: .equ	CKSEL2	= 2	; Select Clock source
   594: .equ	CKSEL3	= 3	; Select Clock source
   595: .equ	SUT0	= 4	; Select start-up time
   596: .equ	SUT1	= 5	; Select start-up time
   597: .equ	CKOUT	= 6	; Clock Output Enable
   598: .equ	CKDIV8	= 7	; Divide clock by 8
   599: 
   600: ; HIGH fuse bits
   601: .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
   602: .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
   603: .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
   604: .equ	EESAVE	= 3	; EEPROM memory is preserved through the Chip Erase
   605: .equ	WDTON	= 4	; Watchdog Timer always on
   606: .equ	SPIEN	= 5	; Enable Serial Program and Data Downloading
   607: .equ	DWEN	= 6	; DebugWIRE Enable
   608: .equ	RSTDISBL	= 7	; External Reset disable
   609: 
   610: ; EXTENDED fuse bits
   611: .equ	SELFPRGEN	= 0	; Self-Programming Enable
   612: 
   613: 
   614: 
   615: ; ***** CPU REGISTER DEFINITIONS *****************************************
   616: .def	XH	= r27
   617: .def	XL	= r26
   618: .def	YH	= r29
   619: .def	YL	= r28
   620: .def	ZH	= r31
   621: .def	ZL	= r30
   622: 
   623: 
   624: 
   625: ; ***** DATA MEMORY DECLARATIONS *****************************************
   626: .equ	FLASHEND	= 0x03ff	; Note: Word address
   627: .equ	IOEND	= 0x003f
   628: .equ	SRAM_START	= 0x0060
   629: .equ	SRAM_SIZE	= 128
   630: .equ	RAMEND	= 0x00df
   631: .equ	XRAMEND	= 0x0000
   632: .equ	E2END	= 0x007f
   633: .equ	EEPROMEND	= 0x007f
   634: .equ	EEADRBITS	= 7
   635: #pragma AVRPART MEMORY PROG_FLASH 2048
   636: #pragma AVRPART MEMORY EEPROM 128
   637: #pragma AVRPART MEMORY INT_SRAM SIZE 128
   638: #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
   639: 
   640: 
   641: 
   642: ; ***** BOOTLOADER DECLARATIONS ******************************************
   643: .equ	NRWW_START_ADDR	= 0x0
   644: .equ	NRWW_STOP_ADDR	= 0x3ff
   645: .equ	RWW_START_ADDR	= 0x0
   646: .equ	RWW_STOP_ADDR	= 0x0
   647: .equ	PAGESIZE	= 16
   648: 
   649: 
   650: 
   651: ; ***** INTERRUPT VECTORS ************************************************
   652: .equ	EXT_INT0addr	= 0x0001	; External Interrupt Request 0
   653: .equ	PCI0addr	= 0x0002	; Pin Change Interrupt Request 0
   654: .equ	PCI1addr	= 0x0003	; Pin Change Interrupt Request 1
   655: .equ	WATCHDOGaddr	= 0x0004	; Watchdog Time-out
   656: .equ	ICP1addr	= 0x0005	; Timer/Counter1 Capture Event
   657: .equ	OC1Aaddr	= 0x0006	; Timer/Counter1 Compare Match A
   658: .equ	OC1Baddr	= 0x0007	; Timer/Counter1 Compare Match B
   659: .equ	OVF1addr	= 0x0008	; Timer/Counter1 Overflow
   660: .equ	OC0Aaddr	= 0x0009	; Timer/Counter0 Compare Match A
   661: .equ	OC0Baddr	= 0x000a	; Timer/Counter0 Compare Match B
   662: .equ	OVF0addr	= 0x000b	; Timer/Counter0 Overflow
   663: .equ	ACIaddr	= 0x000c	; Analog Comparator
   664: .equ	ADCCaddr	= 0x000d	; ADC Conversion Complete
   665: .equ	ERDYaddr	= 0x000e	; EEPROM Ready
   666: .equ	USI_STRaddr	= 0x000f	; USI START
   667: .equ	USI_OVFaddr	= 0x0010	; USI Overflow
   668: 
   669: .equ	INT_VECTORS_SIZE	= 17	; size in words
   670: 
   671: #endif  /* _TN24ADEF_INC_ */
   672: 
   673: ; ***** END OF FILE ******************************************************
   674: 
  Continuing file ish.asm
     2: ; Internal Hardware Init  ======================================
     3: 		.equ 	XTAL = 16000000 	
     4: 
     5: .cseg
     6: .org 0
     7: 000000   ED0F  ldi R16,RamEnd       ;инициализация стека
     8: 000001   BF0D  out SPL,R16
     9: 
    10: 
    11: 
    12: 000002   C019  rjmp Begin
    13: 
    14: 	.include "USI_macro.inc"
  Including file USI_macro.inc
     1: ;===============================================================================================
     2: ; USI def
     3: 
     4: .ifndef XTAL
     5: 	.error "XTAL must be defined!"
     6: .endif
     7: 
     8: 	.equ	USIDelayC	= (XTAL/2000000)	; Задержка для примерно 200kHz
     9: 
    10: 	.equ	DS1307		= 0b11010000	;Адрес часов
    11: 	.equ	USISR_8BIT	= 0xF0			; значение 4х битного счетчика для передачи 8 бит пакета  информации 
    12: 	.equ	USISR_1BIT	= 0xFE			; значение 4х битного счетчика для передачи 9го бита пакета  информации 
    13: 	
    14: 	
    15: 	.equ	SCLPort		= PORTA
    16: 	.equ	SDAPort		= PORTA
    17: 	.equ	SCLPin		= PINA
    18: 	.equ	SDAPin		= PINA
    19: 	.equ	SCLDDR		= DDRA
    20: 	.equ	SDADDR		= DDRA
    21: 	.equ	SCL			= 4
    22: 	.equ	SDA			= 6
    23: 
    24: 
    25: ;===============================================================================================
    26: ; USI Init
    27: 	.MACRO	USI_TWI_INIT
    28: 	SBI SCLDDR, SCL
    29: 	SBI SDADDR, SDA
    30: 	LDI R16, 0<<USISIE|0<<USIOIE|1<<USIWM1|0<<USIWM0|1<<USICS1|0<<USICS0|1<<USICLK|0<<USITC	; Отключаем прерывания, двухпроводной режим без удержания SCL 
    31: 	OUT USICR, R16
    32: 	LDI R16, 1<<USISIF|1<<USIOIF|1<<USIPF|1<<USIDC|0<<USICNT3|0<<USICNT2|0<<USICNT1|0<<USICNT0
    33: 	OUT USISR, R16
    34: 	LDI R17, 0xFF				;ВАЖНО!!!
    35: 	OUT USIDR, R17				;освобождаем линию sda
    36: 	SBI SDAPORT, SDA
    37: 	SBI SCLPORT, SCL
    38: 	RCALL USIDelay
    39: 	
    40: 	.ENDM
    41: 
    42: ;===============================================================================================
    43: ;Start
    44: 	.MACRO	USI_TWI_START
    45: 	SBI SCLPORT, SCL		;перевод SCL в 1
    46: 	RCALL USIDelay
    47: 	SBI SDAPORT, SDA		;на всякий случай выставляем в исходное состояние SDA
    48: 	CBI SCLDDR, SCL			;ВАЖНО!!! отключаем SCL от выходного буфера интерфейса
    49: 	LDI R16, 1<<USISIF|1<<USIOIF|1<<USIPF|1<<USIDC|0<<USICNT3|0<<USICNT2|0<<USICNT1|0<<USICNT0	;сбрасываем USISR
    50: 	OUT USISR, R16
    51: 	CBI SDAPORT, SDA		;переводим  SDA в 0 пока SCL в 1
    52: 	RCALL USIDelay			;тупим нашу задержку
    53: 	SBI SCLDDR, SCL			;ВАЖНО!!! подключаем SCL обратно к выходному буферу интерфейса
    54: 	CBI SCLPORT, SCL		;переводим SCL в 0
    55: 	SBI SDAPORT, SDA		;освобождаем линию SDA для последующей передачи/приема данных
    56: 	RCALL USIDelay			;тупим нашу задержку
    57: 	
    58: 	.ENDM
    59: 
    60: ;===============================================================================================
    61: ;Stop
    62: 	.MACRO	USI_TWI_STOP
    63: 	CBI SCLPORT, SCL		;необязательная подготовка
    64: 	RCALL USIDelay
    65: 	CBI SDAPORT, SDA
    66: 	RCALL USIDelay
    67: 	SBI SCLPORT, SCL		;перевод SCL в 1
    68: 	RCALL USIDelay
    69: 	SBI SDAPORT, SDA		;перевод  SDA в 1
    70: 	RCALL USIDelay
    71: 	IN R16, USISR			;сброс флага детекции состояния Стоп в USISR
    72: 	ORI R16, 1<<USIPF
    73: 	OUT USISR, R16
    74: 
    75: 	.ENDM
    76: 	
    77: ;===============================================================================================
    78: ;Send Byte From R16
    79: 	.MACRO	USI_SEND_B
    80: 	SBIS SCLPIN, SCL			;проверка, если старт не прошел — ставим 0й бит R18 и выходим
    81: 	RJMP NoErrSend
    82: 	ORI R18, 1<<0
    83: 	RJMP ErrSend
    84: NoErrSend:	OUT USIDR, R16				;загружаем байт данных
    85: 	RCALL USI_TWI_Transf_8bit	;посылаем 8 бит
    86: 	CBI SDADDR, SDA				;переклюаемся на прием
    87: 	RCALL USI_TWI_Transf_1bit	;читаем подтверждение
    88: 	SBRC R16,0
    89: 	ORI R18, 1<<0				;Если есть ACK - выходим, иначе ставим 1й бит R18
    90: 	
    91: ErrSend:
    92: 	.ENDM
    93: 	
    94: ;===============================================================================================
    95: ;Send Byte Immediate
    96: 	.MACRO	USI_SEND_BI
    97: 	LDI R16,@0
    98: 	USI_SEND_B
    99: 	.ENDM
   100: 	
   101: ;===============================================================================================
   102: ;Receive Byte
   103: 	.MACRO	USI_READ
   104: 	SBIS SCLPIN, SCL			;проверка, если старт не прошел — ставим 0й бит R18 и выходим
   105: 	RJMP NoErrRead
   106: 	ORI R18, 1<<0
   107: 	RJMP ErrRead
   108: NoErrRead:	CBI SDADDR, SDA				;переклюаемся на прием
   109: 	RCALL USI_TWI_Transf_8bit	;принимаем 8 бит
   110: ErrRead:
   111: 	.ENDM
   112: 	
   113: ;===============================================================================================
   114: ;Receive Byte + ACK
   115: 	.MACRO	USI_READ_B_ACK
   116: 	USI_READ
   117: 	PUSH R16
   118: 	SBRC R18,0
   119: 	RJMP ErrReadACK
   120: 	LDI R16, 0x00	;передаем подтверждение ACK
   121: 	OUT USIDR, R16
   122: 	RCALL USI_TWI_Transf_1bit
   123: 
   124: 	POP R16
   125: ErrReadACK:
   126: 	.ENDM
   127: 
   128: ;===============================================================================================
   129: ;Receive Byte + NACK
   130: 	.MACRO	USI_READ_B_NACK
   131: 	USI_READ
   132: 	PUSH R16
   133: 	SBRC R18,0
   134: 	RJMP ErrReadNACK
   135: 	LDI R16, 0xFF	;передаем NACK
   136: 	OUT USIDR, R16
   137: 	RCALL USI_TWI_Transf_1bit
   138: 
   139: 	POP R16
   140: ErrReadNACK:
   141: 	.ENDM
   142: 
   143: ;===============================================================================================
   144: ;SLA_W
   145: 	.MACRO	USI_SLA_W
   146: 	LDI R16,DS1307	;АДРЕС УСТРОЙСТВА
   147: 	USI_SEND_B
   148: 	
   149: 	.ENDM
   150: 
   151: ;===============================================================================================
   152: ;SLA_R
   153: 	.MACRO	USI_SLA_R
   154: 	LDI R16,DS1307|1<<0	;АДРЕС УСТРОЙСТВА
   155: 	USI_SEND_B
   156: 	
   157: 	.ENDM
   158: 
   159: 
   160: 
   161: ;===============================================================================================
   162: 
   163: 000003   EF00  LDI R16, USISR_8BIT
   164: 000004   C001  RJMP USI_TWI_Transf
   165: 
   166: 000005   EF0E  LDI R16, USISR_1BIT
   167: 000006   B90E  OUT USISR, R16
   168: 
   169: 000007   E21B  LDI R17, 0<<USISIE|0<<USIOIE|1<<USIWM1|0<<USIWM0|1<<USICS1|0<<USICS0|1<<USICLK|1<<USITC	;задаем битовую маску для USICR. USITC самый важный бит					
   170: 000008   D00E  RCALL USIDelay
   171: 000009   B91D  OUT USICR, R17		;запинываем значение в USICR, интерфейс работает 
   172: 00000A   9BCC  SBIS SCLPIN, SCL	;проверяем, свободна-ли линия
   173: 00000B   CFFE  RJMP SCL_CHECK
   174: 00000C   D00A  RCALL USIDelay
   175: 00000D   B91D  OUT USICR, R17		;еще раз запинываем USICR
   176: 00000E   B10E  IN R16, USISR
   177: 00000F   7400  ANDI R16, 1<<USIOIF
   178: 000010   F3B9  BREQ USI_TRANSF		;повторяем предыдущие операции до переполнения счетчика
   179: 
   180: 000011   D005  RCALL USIDelay
   181: 000012   B10F  IN R16, USIDR				;сохраняем принятые данные
   182: 000013   EF1F  LDI R17, 0xFF
   183: 000014   B91F  OUT USIDR, R17				;освобождаем линию sda
   184: 000015   9AD6  SBI SDADDR, SDA				;ВАЖНО!!! восстанавливаем  подключение SDA к выходному буферу интерфейса
   185: 000016   9508  RET
   186: 
   187: ;===============================================================================================
   188: 
   189: 
   190: 000017   E008  LDI R16, 	USIDelayC	;Тупим
   191: 000018   0000  NOP
   192: 000019   950A  DEC R16
   193: 00001A   F7E9  BRNE USILoop
   194: 00001B   9508  RET
  Continuing file ish.asm
    15: 
    16: Begin:
    17: 	USI_TWI_INIT
    18: 	USI_TWI_START
    19: 	USI_SLA_W
    20: 	USI_SEND_BI 0x00
    21: 	USI_SEND_BI 0x00
    22: 	USI_SEND_BI 0x09
    23: 	USI_SEND_BI 0x02
    24: 	USI_SEND_BI 0x01
    25: 	USI_SEND_BI 0x02
    26: 	USI_SEND_BI 0x02
    27: 	USI_SEND_BI 0x15
    28: 	USI_SEND_BI 0x00
    29: 	USI_TWI_STOP
    30: 
    31: 
    32: LOLO:
    33: 0000AC   0000  nop
    34: 0000AD   CFFF  RJMP PC-1
    35: 
 -> Warning 011: C-style instructions in file, lines ignored!
 -> Warning 001: 2 symbol(s) defined, but not used!

Program             :      174 words.
Constants           :        0 words.
Total program memory:      174 words.
Eeprom space        :        0 bytes.
Data segment        :        0 bytes.
Compilation completed, no errors.
Compilation endet 02.02.2015, 02:08:46
