gavrasm Gerd's AVR assembler version 3.4 (C)2014 by DG4FAC
----------------------------------------------------------
Source file: ish.asm
Hex file:    ish.hex
Eeprom file: ish.eep
Compiled:    24.01.2015, 23:10:49
Pass:        2
     1: .include "/home/marik/Project/tn2313Adef.inc"
  Including file /home/marik/Project/tn2313Adef.inc
     1: ;***** THIS IS A MACHINE GENERATED FILE - DO NOT EDIT ********************
     2: ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny2313A.xml *********
     3: ;*************************************************************************
     4: ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
     5: ;* 
     6: ;* Number            : AVR000
     7: ;* File Name         : "tn2313Adef.inc"
     8: ;* Title             : Register/Bit Definitions for the ATtiny2313A
     9: ;* Date              : 2011-02-09
    10: ;* Version           : 2.35
    11: ;* Support E-mail    : avr@atmel.com
    12: ;* Target MCU        : ATtiny2313A
    13: ;* 
    14: ;* DESCRIPTION
    15: ;* When including this file in the assembly program file, all I/O register 
    16: ;* names and I/O register bit names appearing in the data book can be used.
    17: ;* In addition, the six registers forming the three data pointers X, Y and 
    18: ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
    19: ;* SRAM is also defined 
    20: ;* 
    21: ;* The Register names are represented by their hexadecimal address.
    22: ;* 
    23: ;* The Register Bit names are represented by their bit number (0-7).
    24: ;* 
    25: ;* Please observe the difference in using the bit names with instructions
    26: ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
    27: ;* (skip if bit in register set/cleared). The following example illustrates
    28: ;* this:
    29: ;* 
    30: ;* in    r16,PORTB             ;read PORTB latch
    31: ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
    32: ;* out   PORTB,r16             ;output to PORTB
    33: ;* 
    34: ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
    35: ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
    36: ;* rjmp  TOV0_is_set           ;jump if set
    37: ;* ...                         ;otherwise do something else
    38: ;*************************************************************************
    39: 
    40: #ifndef _TN2313ADEF_INC_
    41: #define _TN2313ADEF_INC_
    42: 
    43: 
    44: #pragma partinc 0
    45: 
    46: ; ***** SPECIFY DEVICE ***************************************************
    47: .device ATtiny2313A
    48: #pragma AVRPART ADMIN PART_NAME ATtiny2313A
    49: .equ	SIGNATURE_000	= 0x1e
    50: .equ	SIGNATURE_001	= 0x91
    51: .equ	SIGNATURE_002	= 0x0a
    52: 
    53: #pragma AVRPART CORE CORE_VERSION V2
    54: #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
    55: 
    56: 
    57: ; ***** I/O REGISTER DEFINITIONS *****************************************
    58: ; NOTE:
    59: ; Definitions marked "MEMORY MAPPED"are extended I/O ports
    60: ; and cannot be used with IN/OUT instructions
    61: .equ	SREG	= 0x3f
    62: .equ	SPL	= 0x3d
    63: .equ	OCR0B	= 0x3c
    64: .equ	GIMSK	= 0x3b
    65: .equ	EIFR	= 0x3a
    66: .equ	TIMSK	= 0x39
    67: .equ	TIFR	= 0x38
    68: .equ	SPMCSR	= 0x37
    69: .equ	OCR0A	= 0x36
    70: .equ	MCUCR	= 0x35
    71: .equ	MCUSR	= 0x34
    72: .equ	TCCR0B	= 0x33
    73: .equ	TCNT0	= 0x32
    74: .equ	OSCCAL	= 0x31
    75: .equ	TCCR0A	= 0x30
    76: .equ	TCCR1A	= 0x2f
    77: .equ	TCCR1B	= 0x2e
    78: .equ	TCNT1L	= 0x2c
    79: .equ	TCNT1H	= 0x2d
    80: .equ	OCR1AL	= 0x2a
    81: .equ	OCR1AH	= 0x2b
    82: .equ	OCR1BL	= 0x28
    83: .equ	OCR1BH	= 0x29
    84: .equ	CLKPR	= 0x26
    85: .equ	ICR1L	= 0x24
    86: .equ	ICR1H	= 0x25
    87: .equ	GTCCR	= 0x23
    88: .equ	TCCR1C	= 0x22
    89: .equ	WDTCR	= 0x21
    90: .equ	PCMSK	= 0x20
    91: .equ	EEAR	= 0x1e
    92: .equ	EEDR	= 0x1d
    93: .equ	EECR	= 0x1c
    94: .equ	PORTA	= 0x1b
    95: .equ	DDRA	= 0x1a
    96: .equ	PINA	= 0x19
    97: .equ	PORTB	= 0x18
    98: .equ	DDRB	= 0x17
    99: .equ	PINB	= 0x16
   100: .equ	GPIOR2	= 0x15
   101: .equ	GPIOR1	= 0x14
   102: .equ	GPIOR0	= 0x13
   103: .equ	PORTD	= 0x12
   104: .equ	DDRD	= 0x11
   105: .equ	PIND	= 0x10
   106: .equ	USIDR	= 0x0f
   107: .equ	USISR	= 0x0e
   108: .equ	USICR	= 0x0d
   109: .equ	UDR	= 0x0c
   110: .equ	UCSRA	= 0x0b
   111: .equ	UCSRB	= 0x0a
   112: .equ	UBRRL	= 0x09
   113: .equ	ACSR	= 0x08
   114: .equ	BODCR	= 0x07
   115: .equ	PRR	= 0x06
   116: .equ	PCMSK2	= 0x05
   117: .equ	PCMSK1	= 0x04
   118: .equ	UCSRC	= 0x03
   119: .equ	UBRRH	= 0x02
   120: .equ	DIDR	= 0x01
   121: 
   122: 
   123: ; ***** BIT DEFINITIONS **************************************************
   124: 
   125: ; ***** PORTB ************************
   126: ; PORTB - Port B Data Register
   127: .equ	PORTB0	= 0	; Port B Data Register bit 0
   128: .equ	PB0	= 0	; For compatibility
   129: .equ	PORTB1	= 1	; Port B Data Register bit 1
   130: .equ	PB1	= 1	; For compatibility
   131: .equ	PORTB2	= 2	; Port B Data Register bit 2
   132: .equ	PB2	= 2	; For compatibility
   133: .equ	PORTB3	= 3	; Port B Data Register bit 3
   134: .equ	PB3	= 3	; For compatibility
   135: .equ	PORTB4	= 4	; Port B Data Register bit 4
   136: .equ	PB4	= 4	; For compatibility
   137: .equ	PORTB5	= 5	; Port B Data Register bit 5
   138: .equ	PB5	= 5	; For compatibility
   139: .equ	PORTB6	= 6	; Port B Data Register bit 6
   140: .equ	PB6	= 6	; For compatibility
   141: .equ	PORTB7	= 7	; Port B Data Register bit 7
   142: .equ	PB7	= 7	; For compatibility
   143: 
   144: ; DDRB - Port B Data Direction Register
   145: .equ	DDB0	= 0	; Port B Data Direction Register bit 0
   146: .equ	DDB1	= 1	; Port B Data Direction Register bit 1
   147: .equ	DDB2	= 2	; Port B Data Direction Register bit 2
   148: .equ	DDB3	= 3	; Port B Data Direction Register bit 3
   149: .equ	DDB4	= 4	; Port B Data Direction Register bit 4
   150: .equ	DDB5	= 5	; Port B Data Direction Register bit 5
   151: .equ	DDB6	= 6	; Port B Data Direction Register bit 6
   152: .equ	DDB7	= 7	; Port B Data Direction Register bit 7
   153: 
   154: ; PINB - Port B Input Pins
   155: .equ	PINB0	= 0	; Port B Input Pins bit 0
   156: .equ	PINB1	= 1	; Port B Input Pins bit 1
   157: .equ	PINB2	= 2	; Port B Input Pins bit 2
   158: .equ	PINB3	= 3	; Port B Input Pins bit 3
   159: .equ	PINB4	= 4	; Port B Input Pins bit 4
   160: .equ	PINB5	= 5	; Port B Input Pins bit 5
   161: .equ	PINB6	= 6	; Port B Input Pins bit 6
   162: .equ	PINB7	= 7	; Port B Input Pins bit 7
   163: 
   164: 
   165: ; ***** TIMER_COUNTER_0 **************
   166: ; TIMSK - Timer/Counter Interrupt Mask Register
   167: .equ	OCIE0A	= 0	; Timer/Counter0 Output Compare Match A Interrupt Enable
   168: .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
   169: .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
   170: 
   171: ; TIFR - Timer/Counter Interrupt Flag register
   172: .equ	OCF0A	= 0	; Timer/Counter0 Output Compare Flag 0A
   173: .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
   174: .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
   175: 
   176: ; OCR0B - Timer/Counter0 Output Compare Register
   177: .equ	OCR0_0	= 0	; 
   178: .equ	OCR0_1	= 1	; 
   179: .equ	OCR0_2	= 2	; 
   180: .equ	OCR0_3	= 3	; 
   181: .equ	OCR0_4	= 4	; 
   182: .equ	OCR0_5	= 5	; 
   183: .equ	OCR0_6	= 6	; 
   184: .equ	OCR0_7	= 7	; 
   185: 
   186: ; OCR0A - Timer/Counter0 Output Compare Register
   187: .equ	OCR0A_0	= 0	; 
   188: .equ	OCR0A_1	= 1	; 
   189: .equ	OCR0A_2	= 2	; 
   190: .equ	OCR0A_3	= 3	; 
   191: .equ	OCR0A_4	= 4	; 
   192: .equ	OCR0A_5	= 5	; 
   193: .equ	OCR0A_6	= 6	; 
   194: .equ	OCR0A_7	= 7	; 
   195: 
   196: ; TCCR0A - Timer/Counter  Control Register A
   197: .equ	WGM00	= 0	; Waveform Generation Mode
   198: .equ	WGM01	= 1	; Waveform Generation Mode
   199: .equ	COM0B0	= 4	; Compare Match Output B Mode
   200: .equ	COM0B1	= 5	; Compare Match Output B Mode
   201: .equ	COM0A0	= 6	; Compare Match Output A Mode
   202: .equ	COM0A1	= 7	; Compare Match Output A Mode
   203: 
   204: ; TCNT0 - Timer/Counter0
   205: .equ	TCNT0_0	= 0	; 
   206: .equ	TCNT0_1	= 1	; 
   207: .equ	TCNT0_2	= 2	; 
   208: .equ	TCNT0_3	= 3	; 
   209: .equ	TCNT0_4	= 4	; 
   210: .equ	TCNT0_5	= 5	; 
   211: .equ	TCNT0_6	= 6	; 
   212: .equ	TCNT0_7	= 7	; 
   213: 
   214: ; TCCR0B - Timer/Counter Control Register B
   215: .equ	TCCR0	= TCCR0B	; For compatibility
   216: .equ	CS00	= 0	; Clock Select
   217: .equ	CS01	= 1	; Clock Select
   218: .equ	CS02	= 2	; Clock Select
   219: .equ	WGM02	= 3	; 
   220: .equ	FOC0B	= 6	; Force Output Compare B
   221: .equ	FOC0A	= 7	; Force Output Compare B
   222: 
   223: 
   224: ; ***** TIMER_COUNTER_1 **************
   225: ; TIMSK - Timer/Counter Interrupt Mask Register
   226: .equ	ICIE1	= 3	; Timer/Counter1 Input Capture Interrupt Enable
   227: .equ	TICIE	= ICIE1	; For compatibility
   228: .equ	OCIE1B	= 5	; Timer/Counter1 Output CompareB Match Interrupt Enable
   229: .equ	OCIE1A	= 6	; Timer/Counter1 Output CompareA Match Interrupt Enable
   230: .equ	TOIE1	= 7	; Timer/Counter1 Overflow Interrupt Enable
   231: 
   232: ; TIFR - Timer/Counter Interrupt Flag register
   233: .equ	ICF1	= 3	; Input Capture Flag 1
   234: .equ	OCF1B	= 5	; Output Compare Flag 1B
   235: .equ	OCF1A	= 6	; Output Compare Flag 1A
   236: .equ	TOV1	= 7	; Timer/Counter1 Overflow Flag
   237: 
   238: ; TCCR1A - Timer/Counter1 Control Register A
   239: .equ	WGM10	= 0	; Pulse Width Modulator Select Bit 0
   240: .equ	PWM10	= WGM10	; For compatibility
   241: .equ	WGM11	= 1	; Pulse Width Modulator Select Bit 1
   242: .equ	PWM11	= WGM11	; For compatibility
   243: .equ	COM1B0	= 4	; Comparet Ouput Mode 1B, bit 0
   244: .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
   245: .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
   246: .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
   247: 
   248: ; TCCR1B - Timer/Counter1 Control Register B
   249: .equ	CS10	= 0	; Clock Select bit 0
   250: .equ	CS11	= 1	; Clock Select 1 bit 1
   251: .equ	CS12	= 2	; Clock Select1 bit 2
   252: .equ	WGM12	= 3	; Waveform Generation Mode Bit 2
   253: .equ	CTC1	= WGM12	; For compatibility
   254: .equ	WGM13	= 4	; Waveform Generation Mode Bit 3
   255: .equ	ICES1	= 6	; Input Capture 1 Edge Select
   256: .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
   257: 
   258: ; TCCR1C - Timer/Counter1 Control Register C
   259: .equ	FOC1B	= 6	; Force Output Compare for Channel B
   260: .equ	FOC1A	= 7	; Force Output Compare for Channel A
   261: 
   262: 
   263: ; ***** WATCHDOG *********************
   264: ; WDTCR - Watchdog Timer Control Register
   265: .equ	WDTCSR	= WDTCR	; For compatibility
   266: .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
   267: .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
   268: .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
   269: .equ	WDE	= 3	; Watch Dog Enable
   270: .equ	WDCE	= 4	; Watchdog Change Enable
   271: .equ	WDTOE	= WDCE	; For compatibility
   272: .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
   273: .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
   274: .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
   275: 
   276: 
   277: ; ***** USART ************************
   278: ; UDR - USART I/O Data Register
   279: .equ	UDR0	= 0	; USART I/O Data Register bit 0
   280: .equ	UDR1	= 1	; USART I/O Data Register bit 1
   281: .equ	UDR2	= 2	; USART I/O Data Register bit 2
   282: .equ	UDR3	= 3	; USART I/O Data Register bit 3
   283: .equ	UDR4	= 4	; USART I/O Data Register bit 4
   284: .equ	UDR5	= 5	; USART I/O Data Register bit 5
   285: .equ	UDR6	= 6	; USART I/O Data Register bit 6
   286: .equ	UDR7	= 7	; USART I/O Data Register bit 7
   287: 
   288: ; UCSRA - USART Control and Status Register A
   289: .equ	USR	= UCSRA	; For compatibility
   290: .equ	MPCM	= 0	; Multi-processor Communication Mode
   291: .equ	U2X	= 1	; Double the USART Transmission Speed
   292: .equ	UPE	= 2	; USART Parity Error
   293: .equ	PE	= UPE	; For compatibility
   294: .equ	DOR	= 3	; Data overRun
   295: .equ	FE	= 4	; Framing Error
   296: .equ	UDRE	= 5	; USART Data Register Empty
   297: .equ	TXC	= 6	; USART Transmitt Complete
   298: .equ	RXC	= 7	; USART Receive Complete
   299: 
   300: ; UCSRB - USART Control and Status Register B
   301: .equ	UCR	= UCSRB	; For compatibility
   302: .equ	TXB8	= 0	; Transmit Data Bit 8
   303: .equ	RXB8	= 1	; Receive Data Bit 8
   304: .equ	UCSZ2	= 2	; Character Size
   305: .equ	CHR9	= UCSZ2	; For compatibility
   306: .equ	TXEN	= 3	; Transmitter Enable
   307: .equ	RXEN	= 4	; Receiver Enable
   308: .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
   309: .equ	TXCIE	= 6	; TX Complete Interrupt Enable
   310: .equ	RXCIE	= 7	; RX Complete Interrupt Enable
   311: 
   312: ; UCSRC - USART Control and Status Register C
   313: .equ	UCPOL	= 0	; Clock Polarity
   314: .equ	UCSZ0	= 1	; Character Size Bit 0
   315: .equ	UCSZ1	= 2	; Character Size Bit 1
   316: .equ	USBS	= 3	; Stop Bit Select
   317: .equ	UPM0	= 4	; Parity Mode Bit 0
   318: .equ	UPM1	= 5	; Parity Mode Bit 1
   319: .equ	UMSEL	= 6	; USART Mode Select
   320: 
   321: .equ	UBRR	= UBRRL	; For compatibility
   322: 
   323: ; ***** ANALOG_COMPARATOR ************
   324: ; ACSR - Analog Comparator Control And Status Register
   325: .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
   326: .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
   327: .equ	ACIC	= 2	; 
   328: .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
   329: .equ	ACI	= 4	; Analog Comparator Interrupt Flag
   330: .equ	ACO	= 5	; Analog Compare Output
   331: .equ	ACBG	= 6	; Analog Comparator Bandgap Select
   332: .equ	ACD	= 7	; Analog Comparator Disable
   333: 
   334: ; DIDR - Digital Input Disable Register 1
   335: .equ	AIN0D	= 0	; AIN0 Digital Input Disable
   336: .equ	AIN1D	= 1	; AIN1 Digital Input Disable
   337: 
   338: 
   339: ; ***** PORTD ************************
   340: ; PORTD - Data Register, Port D
   341: .equ	PORTD0	= 0	; 
   342: .equ	PD0	= 0	; For compatibility
   343: .equ	PORTD1	= 1	; 
   344: .equ	PD1	= 1	; For compatibility
   345: .equ	PORTD2	= 2	; 
   346: .equ	PD2	= 2	; For compatibility
   347: .equ	PORTD3	= 3	; 
   348: .equ	PD3	= 3	; For compatibility
   349: .equ	PORTD4	= 4	; 
   350: .equ	PD4	= 4	; For compatibility
   351: .equ	PORTD5	= 5	; 
   352: .equ	PD5	= 5	; For compatibility
   353: .equ	PORTD6	= 6	; 
   354: .equ	PD6	= 6	; For compatibility
   355: 
   356: ; DDRD - Data Direction Register, Port D
   357: .equ	DDD0	= 0	; 
   358: .equ	DDD1	= 1	; 
   359: .equ	DDD2	= 2	; 
   360: .equ	DDD3	= 3	; 
   361: .equ	DDD4	= 4	; 
   362: .equ	DDD5	= 5	; 
   363: .equ	DDD6	= 6	; 
   364: 
   365: ; PIND - Input Pins, Port D
   366: .equ	PIND0	= 0	; 
   367: .equ	PIND1	= 1	; 
   368: .equ	PIND2	= 2	; 
   369: .equ	PIND3	= 3	; 
   370: .equ	PIND4	= 4	; 
   371: .equ	PIND5	= 5	; 
   372: .equ	PIND6	= 6	; 
   373: 
   374: 
   375: ; ***** EEPROM ***********************
   376: ; EEAR - EEPROM Read/Write Access
   377: .equ	EEARL	= EEAR	; For compatibility
   378: .equ	EEAR0	= 0	; EEPROM Read/Write Access bit 0
   379: .equ	EEAR1	= 1	; EEPROM Read/Write Access bit 1
   380: .equ	EEAR2	= 2	; EEPROM Read/Write Access bit 2
   381: .equ	EEAR3	= 3	; EEPROM Read/Write Access bit 3
   382: .equ	EEAR4	= 4	; EEPROM Read/Write Access bit 4
   383: .equ	EEAR5	= 5	; EEPROM Read/Write Access bit 5
   384: .equ	EEAR6	= 6	; EEPROM Read/Write Access bit 6
   385: 
   386: ; EEDR - EEPROM Data Register
   387: .equ	EEDR0	= 0	; EEPROM Data Register bit 0
   388: .equ	EEDR1	= 1	; EEPROM Data Register bit 1
   389: .equ	EEDR2	= 2	; EEPROM Data Register bit 2
   390: .equ	EEDR3	= 3	; EEPROM Data Register bit 3
   391: .equ	EEDR4	= 4	; EEPROM Data Register bit 4
   392: .equ	EEDR5	= 5	; EEPROM Data Register bit 5
   393: .equ	EEDR6	= 6	; EEPROM Data Register bit 6
   394: .equ	EEDR7	= 7	; EEPROM Data Register bit 7
   395: 
   396: ; EECR - EEPROM Control Register
   397: .equ	EERE	= 0	; EEPROM Read Enable
   398: .equ	EEPE	= 1	; EEPROM Write Enable
   399: .equ	EEWE	= EEPE	; For compatibility
   400: .equ	EEMPE	= 2	; EEPROM Master Write Enable
   401: .equ	EEMWE	= EEMPE	; For compatibility
   402: .equ	EERIE	= 3	; EEProm Ready Interrupt Enable
   403: .equ	EEPM0	= 4	; 
   404: .equ	EEPM1	= 5	; 
   405: 
   406: 
   407: ; ***** PORTA ************************
   408: ; PORTA - Port A Data Register
   409: .equ	PORTA0	= 0	; Port A Data Register bit 0
   410: .equ	PA0	= 0	; For compatibility
   411: .equ	PORTA1	= 1	; Port A Data Register bit 1
   412: .equ	PA1	= 1	; For compatibility
   413: .equ	PORTA2	= 2	; Port A Data Register bit 2
   414: .equ	PA2	= 2	; For compatibility
   415: 
   416: ; DDRA - Port A Data Direction Register
   417: .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
   418: .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
   419: .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
   420: 
   421: ; PINA - Port A Input Pins
   422: .equ	PINA0	= 0	; Input Pins, Port A bit 0
   423: .equ	PINA1	= 1	; Input Pins, Port A bit 1
   424: .equ	PINA2	= 2	; Input Pins, Port A bit 2
   425: 
   426: 
   427: ; ***** USI **************************
   428: ; USIDR - USI Data Register
   429: .equ	USIDR0	= 0	; USI Data Register bit 0
   430: .equ	USIDR1	= 1	; USI Data Register bit 1
   431: .equ	USIDR2	= 2	; USI Data Register bit 2
   432: .equ	USIDR3	= 3	; USI Data Register bit 3
   433: .equ	USIDR4	= 4	; USI Data Register bit 4
   434: .equ	USIDR5	= 5	; USI Data Register bit 5
   435: .equ	USIDR6	= 6	; USI Data Register bit 6
   436: .equ	USIDR7	= 7	; USI Data Register bit 7
   437: 
   438: ; USISR - USI Status Register
   439: .equ	USICNT0	= 0	; USI Counter Value Bit 0
   440: .equ	USICNT1	= 1	; USI Counter Value Bit 1
   441: .equ	USICNT2	= 2	; USI Counter Value Bit 2
   442: .equ	USICNT3	= 3	; USI Counter Value Bit 3
   443: .equ	USIDC	= 4	; Data Output Collision
   444: .equ	USIPF	= 5	; Stop Condition Flag
   445: .equ	USIOIF	= 6	; Counter Overflow Interrupt Flag
   446: .equ	USISIF	= 7	; Start Condition Interrupt Flag
   447: 
   448: ; USICR - USI Control Register
   449: .equ	USITC	= 0	; Toggle Clock Port Pin
   450: .equ	USICLK	= 1	; Clock Strobe
   451: .equ	USICS0	= 2	; USI Clock Source Select Bit 0
   452: .equ	USICS1	= 3	; USI Clock Source Select Bit 1
   453: .equ	USIWM0	= 4	; USI Wire Mode Bit 0
   454: .equ	USIWM1	= 5	; USI Wire Mode Bit 1
   455: .equ	USIOIE	= 6	; Counter Overflow Interrupt Enable
   456: .equ	USISIE	= 7	; Start Condition Interrupt Enable
   457: 
   458: 
   459: ; ***** EXTERNAL_INTERRUPT ***********
   460: ; GIMSK - General Interrupt Mask Register
   461: .equ	PCIE	= 5	; 
   462: .equ	INT0	= 6	; External Interrupt Request 0 Enable
   463: .equ	INT1	= 7	; External Interrupt Request 1 Enable
   464: 
   465: ; EIFR - Extended Interrupt Flag Register
   466: .equ	GIFR	= EIFR	; For compatibility
   467: .equ	PCIF	= 5	; 
   468: .equ	INTF0	= 6	; External Interrupt Flag 0
   469: .equ	INTF1	= 7	; External Interrupt Flag 1
   470: 
   471: ; PCMSK2 - Pin Change Interrupt Mask Register 2
   472: .equ	PCINT11	= 0	; Pin Change Interrupt Mask 11
   473: .equ	PCINT12	= 1	; Pin Change Interrupt Mask 12
   474: .equ	PCINT13	= 2	; Pin Change Interrupt Mask 13
   475: .equ	PCINT14	= 3	; Pin Change Interrupt Mask 14
   476: .equ	PCINT15	= 4	; Pin Change Interrupt Mask 15
   477: .equ	PCINT16	= 5	; Pin Change Interrupt Mask 16
   478: .equ	PCINT17	= 6	; Pin Change Interrupt Mask 17
   479: 
   480: ; PCMSK1 - Pin Change Interrupt Mask Register 1
   481: .equ	PCINT8	= 0	; Pin Change Interrupt Mask 8
   482: .equ	PCINT9	= 1	; Pin Change Interrupt Mask 9
   483: .equ	PCINT10	= 2	; Pin Change Interrupt Mask 10
   484: 
   485: 
   486: ; ***** CPU **************************
   487: ; SREG - Status Register
   488: .equ	SREG_C	= 0	; Carry Flag
   489: .equ	SREG_Z	= 1	; Zero Flag
   490: .equ	SREG_N	= 2	; Negative Flag
   491: .equ	SREG_V	= 3	; Two's Complement Overflow Flag
   492: .equ	SREG_S	= 4	; Sign Bit
   493: .equ	SREG_H	= 5	; Half Carry Flag
   494: .equ	SREG_T	= 6	; Bit Copy Storage
   495: .equ	SREG_I	= 7	; Global Interrupt Enable
   496: 
   497: ; SPMCSR - Store Program Memory Control and Status register
   498: .equ	SPMEN	= 0	; Store Program Memory Enable
   499: .equ	PGERS	= 1	; Page Erase
   500: .equ	PGWRT	= 2	; Page Write
   501: .equ	RFLB	= 3	; Read Fuse and Lock Bits
   502: .equ	CTPB	= 4	; Clear Temporary Page Buffer
   503: 
   504: ; MCUCR - MCU Control Register
   505: .equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
   506: .equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
   507: .equ	ISC10	= 2	; Interrupt Sense Control 1 bit 0
   508: .equ	ISC11	= 3	; Interrupt Sense Control 1 bit 1
   509: .equ	SM0	= 4	; Sleep Mode Select Bit 0
   510: .equ	SM	= SM0	; For compatibility
   511: .equ	SE	= 5	; Sleep Enable
   512: .equ	SM1	= 6	; Sleep Mode Select Bit 1
   513: .equ	PUD	= 7	; Pull-up Disable
   514: 
   515: ; CLKPR - Clock Prescale Register
   516: .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
   517: .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
   518: .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
   519: .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
   520: .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
   521: 
   522: ; MCUSR - MCU Status register
   523: .equ	PORF	= 0	; Power-On Reset Flag
   524: .equ	EXTRF	= 1	; External Reset Flag
   525: .equ	BORF	= 2	; Brown-out Reset Flag
   526: .equ	WDRF	= 3	; Watchdog Reset Flag
   527: 
   528: ; OSCCAL - Oscillator Calibration Register
   529: .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
   530: .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
   531: .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
   532: .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
   533: .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
   534: .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
   535: .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
   536: 
   537: ; GTCCR - General Timer Counter Control Register
   538: .equ	SFIOR	= GTCCR	; For compatibility
   539: .equ	PSR10	= 0	; 
   540: 
   541: ; PCMSK - Pin-Change Mask register
   542: .equ	PCINT0	= 0	; Pin-Change Interrupt 0
   543: .equ	PCINT1	= 1	; Pin-Change Interrupt 1
   544: .equ	PCINT2	= 2	; Pin-Change Interrupt 2
   545: .equ	PCINT3	= 3	; Pin-Change Interrupt 3
   546: .equ	PCINT4	= 4	; Pin-Change Interrupt 4
   547: .equ	PCINT5	= 5	; Pin-Change Interrupt 5
   548: .equ	PCINT6	= 6	; Pin-Change Interrupt 6
   549: .equ	PCINT7	= 7	; Pin-Change Interrupt 7
   550: 
   551: ; GPIOR2 - General Purpose I/O Register 2
   552: .equ	GPIOR20	= 0	; General Purpose I/O Register 2 bit 0
   553: .equ	GPIOR21	= 1	; General Purpose I/O Register 2 bit 1
   554: .equ	GPIOR22	= 2	; General Purpose I/O Register 2 bit 2
   555: .equ	GPIOR23	= 3	; General Purpose I/O Register 2 bit 3
   556: .equ	GPIOR24	= 4	; General Purpose I/O Register 2 bit 4
   557: .equ	GPIOR25	= 5	; General Purpose I/O Register 2 bit 5
   558: .equ	GPIOR26	= 6	; General Purpose I/O Register 2 bit 6
   559: .equ	GPIOR27	= 7	; General Purpose I/O Register 2 bit 7
   560: 
   561: ; GPIOR1 - General Purpose I/O Register 1
   562: .equ	GPIOR10	= 0	; General Purpose I/O Register 1 bit 0
   563: .equ	GPIOR11	= 1	; General Purpose I/O Register 1 bit 1
   564: .equ	GPIOR12	= 2	; General Purpose I/O Register 1 bit 2
   565: .equ	GPIOR13	= 3	; General Purpose I/O Register 1 bit 3
   566: .equ	GPIOR14	= 4	; General Purpose I/O Register 1 bit 4
   567: .equ	GPIOR15	= 5	; General Purpose I/O Register 1 bit 5
   568: .equ	GPIOR16	= 6	; General Purpose I/O Register 1 bit 6
   569: .equ	GPIOR17	= 7	; General Purpose I/O Register 1 bit 7
   570: 
   571: ; GPIOR0 - General Purpose I/O Register 0
   572: .equ	GPIOR00	= 0	; General Purpose I/O Register 0 bit 0
   573: .equ	GPIOR01	= 1	; General Purpose I/O Register 0 bit 1
   574: .equ	GPIOR02	= 2	; General Purpose I/O Register 0 bit 2
   575: .equ	GPIOR03	= 3	; General Purpose I/O Register 0 bit 3
   576: .equ	GPIOR04	= 4	; General Purpose I/O Register 0 bit 4
   577: .equ	GPIOR05	= 5	; General Purpose I/O Register 0 bit 5
   578: .equ	GPIOR06	= 6	; General Purpose I/O Register 0 bit 6
   579: .equ	GPIOR07	= 7	; General Purpose I/O Register 0 bit 7
   580: 
   581: ; PRR - Power reduction register
   582: .equ	PRUSART	= 0	; 
   583: .equ	PRUSI	= 1	; 
   584: .equ	PRTIM0	= 2	; 
   585: .equ	PRTIM1	= 3	; 
   586: 
   587: ; BODCR - BOD control register
   588: .equ	BPDSE	= 0	; 
   589: .equ	BPDS	= 1	; 
   590: 
   591: 
   592: 
   593: ; ***** LOCKSBITS ********************************************************
   594: .equ	LB1	= 0	; Lockbit
   595: .equ	LB2	= 1	; Lockbit
   596: 
   597: 
   598: ; ***** FUSES ************************************************************
   599: ; LOW fuse bits
   600: .equ	CKSEL0	= 0	; Select Clock Source
   601: .equ	CKSEL1	= 1	; Select Clock Source
   602: .equ	CKSEL2	= 2	; Select Clock Source
   603: .equ	CKSEL3	= 3	; Select Clock Source
   604: .equ	SUT0	= 4	; Select start-up time
   605: .equ	SUT1	= 5	; Select start-up time
   606: .equ	CKOUT	= 6	; Clock output
   607: .equ	CKDIV8	= 7	; Divide clock by 8
   608: 
   609: ; HIGH fuse bits
   610: .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
   611: .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
   612: .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
   613: .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
   614: .equ	WDTON	= 4	; Watchdog Timer Always On
   615: .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
   616: .equ	DWEN	= 6	; debugWIRE Enable
   617: .equ	RSTDISBL	= 7	; External reset disable
   618: 
   619: ; EXTENDED fuse bits
   620: .equ	SELFPRGEN	= 0	; Self Programming Enable
   621: 
   622: 
   623: 
   624: ; ***** CPU REGISTER DEFINITIONS *****************************************
   625: .def	XH	= r27
   626: .def	XL	= r26
   627: .def	YH	= r29
   628: .def	YL	= r28
   629: .def	ZH	= r31
   630: .def	ZL	= r30
   631: 
   632: 
   633: 
   634: ; ***** DATA MEMORY DECLARATIONS *****************************************
   635: .equ	FLASHEND	= 0x03ff	; Note: Word address
   636: .equ	IOEND	= 0x003f
   637: .equ	SRAM_START	= 0x0060
   638: .equ	SRAM_SIZE	= 128
   639: .equ	RAMEND	= 0x00df
   640: .equ	XRAMEND	= 0x0000
   641: .equ	E2END	= 0x007f
   642: .equ	EEPROMEND	= 0x007f
   643: .equ	EEADRBITS	= 7
   644: #pragma AVRPART MEMORY PROG_FLASH 2048
   645: #pragma AVRPART MEMORY EEPROM 128
   646: #pragma AVRPART MEMORY INT_SRAM SIZE 128
   647: #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
   648: 
   649: 
   650: 
   651: ; ***** BOOTLOADER DECLARATIONS ******************************************
   652: .equ	NRWW_START_ADDR	= 0x0
   653: .equ	NRWW_STOP_ADDR	= 0x3ff
   654: .equ	RWW_START_ADDR	= 0x0
   655: .equ	RWW_STOP_ADDR	= 0x0
   656: .equ	PAGESIZE	= 16
   657: 
   658: 
   659: 
   660: ; ***** INTERRUPT VECTORS ************************************************
   661: .equ	INT0addr	= 0x0001	; External Interrupt Request 0
   662: .equ	INT1addr	= 0x0002	; External Interrupt Request 1
   663: .equ	ICP1addr	= 0x0003	; Timer/Counter1 Capture Event
   664: .equ	OC1Aaddr	= 0x0004	; Timer/Counter1 Compare Match A
   665: .equ	OC1addr	= 0x0004	; For compatibility
   666: .equ	OVF1addr	= 0x0005	; Timer/Counter1 Overflow
   667: .equ	OVF0addr	= 0x0006	; Timer/Counter0 Overflow
   668: .equ	URXCaddr	= 0x0007	; USART, Rx Complete
   669: .equ	URXC0addr	= 0x0007	; For compatibility
   670: .equ	UDREaddr	= 0x0008	; USART Data Register Empty
   671: .equ	UDRE0addr	= 0x0008	; For compatibility
   672: .equ	UTXCaddr	= 0x0009	; USART, Tx Complete
   673: .equ	UTXC0addr	= 0x0009	; For compatibility
   674: .equ	ACIaddr	= 0x000a	; Analog Comparator
   675: .equ	PCIBaddr	= 0x000b	; Pin Change Interrupt Request B
   676: .equ	PCIaddr	= 0x000b	; For compatibility
   677: .equ	OC1Baddr	= 0x000c	; 
   678: .equ	OC0Aaddr	= 0x000d	; 
   679: .equ	OC0Baddr	= 0x000e	; 
   680: .equ	USI_STARTaddr	= 0x000f	; USI Start Condition
   681: .equ	USI_OVFaddr	= 0x0010	; USI Overflow
   682: .equ	ERDYaddr	= 0x0011	; 
   683: .equ	WDTaddr	= 0x0012	; Watchdog Timer Overflow
   684: .equ	PCIAaddr	= 0x0013	; Pin Change Interrupt Request A
   685: .equ	PCIDaddr	= 0x0014	; Pin Change Interrupt Request D
   686: 
   687: .equ	INT_VECTORS_SIZE	= 21	; size in words
   688: 
   689: #endif  /* _TN2313ADEF_INC_ */
   690: 
   691: ; ***** END OF FILE ******************************************************
   692: 
  Continuing file ish.asm
     2: ; Internal Hardware Init  ======================================
     3: 		.equ 	XTAL = 20000000 	
     4: 		.equ 	baudrate = 9600  
     5: 		.equ 	bauddivider = XTAL/(16*baudrate)-1
     6: 
     7: .DSEG
     8: TimeInASCII:	.byte	8
     9: NumberInASCII:	.byte	5
    10: 
    11: .cseg
    12: .org 0
    13: 000000   ED0F  ldi R16,RamEnd       ;инициализация стека
    14: 000001   BF0D  out SPL,R16
    15: 
    16: 000002   E801  LDI 	R16, low(bauddivider)
    17: 000003   B909  OUT 	UBRRL,R16
    18: 000004   E000  LDI 	R16, high(bauddivider)
    19: 000005   B902  OUT 	UBRRH,R16
    20:  
    21: 000006   E000  LDI 	R16,0
    22: 000007   B90B  OUT 	UCSRA, R16
    23:  
    24: ; Прерывания запрещены, прием-передача разрешен.
    25: 000008   E108  LDI 	R16, (1<<RXEN)|(1<<TXEN)|(0<<RXCIE)|(0<<TXCIE)|(0<<UDRIE)
    26: 000009   B90A  OUT 	UCSRB, R16	
    27:  
    28: ; Формат кадра - 8 бит, пишем в регистр UCSRC, за это отвечает бит селектор
    29: 00000A   E006  LDI 	R16, (1<<UCSZ0)|(1<<UCSZ1)
    30: 00000B   B903  OUT 	UCSRC, R16
    31: 00000C   9A8E  SBI DDRD, 6
    32: 00000D   9896  CBI PORTD, 6
    33: 
    34: 00000E   C019  rjmp ReadTime
    35: 	.include "USI_macro.inc"
  Including file USI_macro.inc
     1: ;===============================================================================================
     2: ; USI def
     3: 
     4: .ifndef XTAL
     5: 	.error "XTAL must be defined!"
     6: .endif
     7: 
     8: 	.equ	USIDelayC	= (XTAL/2000000)	; Задержка для примерно 200kHz
     9: 
    10: 	.equ	DS1307		= 0b11010000	;Адрес часов
    11: 	.equ	USISR_8BIT	= 0xF0			; значение 4х битного счетчика для передачи 8 бит пакета  информации 
    12: 	.equ	USISR_1BIT	= 0xFE			; значение 4х битного счетчика для передачи 9го бита пакета  информации 
    13: 	
    14: 	
    15: 	.equ	SCLPort		= PORTB
    16: 	.equ	SDAPort		= PORTB
    17: 	.equ	SCLPin		= PINB
    18: 	.equ	SDAPin		= PINB
    19: 	.equ	SCLDDR		= DDRB
    20: 	.equ	SDADDR		= DDRB
    21: 	.equ	SCL			= 7
    22: 	.equ	SDA			= 5
    23: 
    24: 
    25: ;===============================================================================================
    26: ; USI Init
    27: 	.MACRO	USI_TWI_INIT
    28: 	SBI SCLDDR, SCL
    29: 	SBI SDADDR, SDA
    30: 	LDI R16, 0<<USISIE|0<<USIOIE|1<<USIWM1|0<<USIWM0|1<<USICS1|0<<USICS0|1<<USICLK|0<<USITC	; Отключаем прерывания, двухпроводной режим без удержания SCL 
    31: 	OUT USICR, R16
    32: 	LDI R16, 1<<USISIF|1<<USIOIF|1<<USIPF|1<<USIDC|0<<USICNT3|0<<USICNT2|0<<USICNT1|0<<USICNT0
    33: 	OUT USISR, R16
    34: 	LDI R17, 0xFF				;ВАЖНО!!!
    35: 	OUT USIDR, R17				;освобождаем линию sda
    36: 	SBI SDAPORT, SDA
    37: 	SBI SCLPORT, SCL
    38: 	RCALL USIDelay
    39: 	
    40: 	.ENDM
    41: 
    42: ;===============================================================================================
    43: ;Start
    44: 	.MACRO	USI_TWI_START
    45: 	SBI SCLPORT, SCL		;перевод SCL в 1
    46: 	RCALL USIDelay
    47: 	SBI SDAPORT, SDA		;на всякий случай выставляем в исходное состояние SDA
    48: 	CBI SCLDDR, SCL			;ВАЖНО!!! отключаем SCL от выходного буфера интерфейса
    49: 	LDI R16, 1<<USISIF|1<<USIOIF|1<<USIPF|1<<USIDC|0<<USICNT3|0<<USICNT2|0<<USICNT1|0<<USICNT0	;сбрасываем USISR
    50: 	OUT USISR, R16
    51: 	CBI SDAPORT, SDA		;переводим  SDA в 0 пока SCL в 1
    52: 	RCALL USIDelay			;тупим нашу задержку
    53: 	SBI SCLDDR, SCL			;ВАЖНО!!! подключаем SCL обратно к выходному буферу интерфейса
    54: 	CBI SCLPORT, SCL		;переводим SCL в 0
    55: 	SBI SDAPORT, SDA		;освобождаем линию SDA для последующей передачи/приема данных
    56: 	RCALL USIDelay			;тупим нашу задержку
    57: 	
    58: 	.ENDM
    59: 
    60: ;===============================================================================================
    61: ;Stop
    62: 	.MACRO	USI_TWI_STOP
    63: 	CBI SCLPORT, SCL		;необязательная подготовка
    64: 	RCALL USIDelay
    65: 	CBI SDAPORT, SDA
    66: 	RCALL USIDelay
    67: 	SBI SCLPORT, SCL		;перевод SCL в 1
    68: 	RCALL USIDelay
    69: 	SBI SDAPORT, SDA		;перевод  SDA в 1
    70: 	RCALL USIDelay
    71: 	IN R16, USISR			;сброс флага детекции состояния Стоп в USISR
    72: 	ORI R16, 1<<USIPF
    73: 	OUT USISR, R16
    74: 
    75: 	.ENDM
    76: 	
    77: ;===============================================================================================
    78: ;Send Byte From R16
    79: 	.MACRO	USI_SEND_B
    80: 	SBIS SCLPIN, SCL			;проверка, если старт не прошел — ставим 0й бит R18 и выходим
    81: 	RJMP NoErrSend
    82: 	ORI R18, 1<<0
    83: 	RJMP ErrSend
    84: NoErrSend:	OUT USIDR, R16				;загружаем байт данных
    85: 	RCALL USI_TWI_Transf_8bit	;посылаем 8 бит
    86: 	CBI SDADDR, SDA				;переклюаемся на прием
    87: 	RCALL USI_TWI_Transf_1bit	;читаем подтверждение
    88: 	SBRC R16,0
    89: 	ORI R18, 1<<0				;Если есть ACK - выходим, иначе ставим 1й бит R18
    90: 	
    91: ErrSend:
    92: 	.ENDM
    93: 	
    94: ;===============================================================================================
    95: ;Send Byte Immediate
    96: 	.MACRO	USI_SEND_BI
    97: 	LDI R16,@0
    98: 	USI_SEND_B
    99: 	.ENDM
   100: 	
   101: ;===============================================================================================
   102: ;Receive Byte
   103: 	.MACRO	USI_READ
   104: 	SBIS SCLPIN, SCL			;проверка, если старт не прошел — ставим 0й бит R18 и выходим
   105: 	RJMP NoErrRead
   106: 	ORI R18, 1<<0
   107: 	RJMP ErrRead
   108: NoErrRead:	CBI SDADDR, SDA				;переклюаемся на прием
   109: 	RCALL USI_TWI_Transf_8bit	;принимаем 8 бит
   110: ErrRead:
   111: 	.ENDM
   112: 	
   113: ;===============================================================================================
   114: ;Receive Byte + ACK
   115: 	.MACRO	USI_READ_B_ACK
   116: 	USI_READ
   117: 	PUSH R16
   118: 	SBRC R18,0
   119: 	RJMP ErrReadACK
   120: 	LDI R16, 0x00	;передаем подтверждение ACK
   121: 	OUT USIDR, R16
   122: 	RCALL USI_TWI_Transf_1bit
   123: 
   124: 	POP R16
   125: ErrReadACK:
   126: 	.ENDM
   127: 
   128: ;===============================================================================================
   129: ;Receive Byte + NACK
   130: 	.MACRO	USI_READ_B_NACK
   131: 	USI_READ
   132: 	PUSH R16
   133: 	SBRC R18,0
   134: 	RJMP ErrReadNACK
   135: 	LDI R16, 0xFF	;передаем NACK
   136: 	OUT USIDR, R16
   137: 	RCALL USI_TWI_Transf_1bit
   138: 
   139: 	POP R16
   140: ErrReadNACK:
   141: 	.ENDM
   142: 
   143: ;===============================================================================================
   144: ;SLA_W
   145: 	.MACRO	USI_SLA_W
   146: 	LDI R16,DS1307	;АДРЕС УСТРОЙСТВА
   147: 	USI_SEND_B
   148: 	
   149: 	.ENDM
   150: 
   151: ;===============================================================================================
   152: ;SLA_R
   153: 	.MACRO	USI_SLA_R
   154: 	LDI R16,DS1307|1<<0	;АДРЕС УСТРОЙСТВА
   155: 	USI_SEND_B
   156: 	
   157: 	.ENDM
   158: 
   159: 
   160: 
   161: ;===============================================================================================
   162: 
   163: 00000F   EF00  LDI R16, USISR_8BIT
   164: 000010   C001  RJMP USI_TWI_Transf
   165: 
   166: 000011   EF0E  LDI R16, USISR_1BIT
   167: 000012   B90E  OUT USISR, R16
   168: 
   169: 000013   E21B  LDI R17, 0<<USISIE|0<<USIOIE|1<<USIWM1|0<<USIWM0|1<<USICS1|0<<USICS0|1<<USICLK|1<<USITC	;задаем битовую маску для USICR. USITC самый важный бит					
   170: 000014   D00E  RCALL USIDelay
   171: 000015   B91D  OUT USICR, R17		;запинываем значение в USICR, интерфейс работает 
   172: 000016   9BB7  SBIS SCLPIN, SCL	;проверяем, свободна-ли линия
   173: 000017   CFFE  RJMP SCL_CHECK
   174: 000018   D00A  RCALL USIDelay
   175: 000019   B91D  OUT USICR, R17		;еще раз запинываем USICR
   176: 00001A   B10E  IN R16, USISR
   177: 00001B   7400  ANDI R16, 1<<USIOIF
   178: 00001C   F3B9  BREQ USI_TRANSF		;повторяем предыдущие операции до переполнения счетчика
   179: 
   180: 00001D   D005  RCALL USIDelay
   181: 00001E   B10F  IN R16, USIDR				;сохраняем принятые данные
   182: 00001F   EF1F  LDI R17, 0xFF
   183: 000020   B91F  OUT USIDR, R17				;освобождаем линию sda
   184: 000021   9ABD  SBI SDADDR, SDA				;ВАЖНО!!! восстанавливаем  подключение SDA к выходному буферу интерфейса
   185: 000022   9508  RET
   186: 
   187: ;===============================================================================================
   188: 
   189: 
   190: 000023   E00A  LDI R16, 	USIDelayC	;Тупим
   191: 000024   0000  NOP
   192: 000025   950A  DEC R16
   193: 000026   F7E9  BRNE USILoop
   194: 000027   9508  RET
  Continuing file ish.asm
    36: ReadTime:
    37: 	USI_TWI_INIT
    38: 	USI_TWI_START
    39: 	USI_SLA_W
    40: 	USI_SEND_BI 0x00
    41: 	USI_TWI_START
    42: 	USI_SLA_R
    43: 	USI_READ_B_ACK
    44: 000079   2EA0  MOV R10,R16	;Записали секунды в R10
    45: 	USI_READ_B_ACK
    46: 000087   2EB0  MOV R11,R16	;Записали минуты в R11
    47: 	USI_READ_B_NACK
    48: 000095   2EC0  MOV R12,R16	;Записали Часы в R12
    49: 	USI_TWI_STOP
    50: 	
    51: 
    52: 0000A1   D097  rcall TimeToASCII
    53: 0000A2   E6E0  ldi ZL,Low(TimeInASCII)
    54: 0000A3   E0F0  ldi ZH,High(TimeInASCII)  ;загрузка начального адреса массива
    55: 0000A4   E028  LDI R18,8
    56: 	
    57: 0000A5   9101  LD	R16, Z+
    58: 0000A6   D08E  rcall uart_snt
    59: 0000A7   952A  DEC R18
    60: 0000A8   2322  TST R18
    61: 0000A9   F7D9  brne Risuy
    62: 0000AA   E00A  LDI R16, 0x0A	;На новую строку
    63: 0000AB   D089  rcall uart_snt
    64: 0000AC   E00D  LDI R16, 0x0D	;в начало строки
    65: 0000AD   D087  rcall uart_snt
    66: 
    67: 	USI_TWI_START
    68: 	USI_SLA_W
    69: 	USI_SEND_BI 0x11
    70: 	USI_TWI_START
    71: 	USI_SLA_R
    72: 	USI_READ_B_ACK
    73: 	
    74: 0000F4   2F70  MOV R23,R16	;Записали Старший в R23
    75: 	USI_READ_B_NACK
    76: 000102   2F60  MOV R22,R16	;Записали младший в R22
    77: 	USI_TWI_STOP
    78: 00010E   9577  ROR R23
    79: 00010F   9567  ROR R22
    80: 000110   9577  ROR R23
    81: 000111   9567  ROR R22
    82: 000112   9577  ROR R23
    83: 000113   9567  ROR R22
    84: 000114   9577  ROR R23
    85: 000115   9567  ROR R22
    86: 
    87: 
    88: 000116   D051  rcall t_convert
    89: 000117   2F07  MOV R16,R23
    90: 000118   2F16  MOV R17,R22
    91: 000119   D076  rcall NumToASCII
    92: 00011A   E6E8  ldi ZL,Low(NumberInASCII)
    93: 00011B   E0F0  ldi ZH,High(NumberInASCII)  ;загрузка начального адреса массива
    94: 00011C   E025  LDI R18,5
    95: 	
    96: 00011D   9101  LD	R16, Z+
    97: 00011E   D016  rcall uart_snt
    98: 00011F   952A  DEC R18
    99: 000120   2322  TST R18
   100: 000121   F7D9  brne Risuy2
   101: 000122   E00A  LDI R16, 0x0A	;На новую строку
   102: 000123   D011  rcall uart_snt
   103: 000124   E00D  LDI R16, 0x0D	;в начало строки
   104: 000125   D00F  rcall uart_snt
   105: 000126   E604  LDI R16, 100
   106: 000127   D001  rcall Delay
   107: 000128   CEFF  RJMP ReadTime
   108: 
   109: 000129   2E80  MOV R8, R16
   110: 00012A   E000  LDI R16, 0	;задержка (0,0,24 - 0,5 секунды)
   111: 00012B   2E60  MOV R6, R16
   112: 00012C   E000  LDI R16, 0
   113: 00012D   2E70  MOV R7, R16
   114: 
   115: 00012E   946A  dec R6
   116: 00012F   F7F1  brne Loop1
   117: 
   118: 000130   947A  dec R7
   119: 000131   F7E1  brne Loop1
   120: 
   121: 000132   948A  dec R8
   122: 000133   F7D1  brne Loop1
   123: 000134   9508  ret
   124: 
   125: 
   126: ; Процедура отправки байта
   127: 000135   9B5D  SBIS 	UCSRA,UDRE	; Пропуск если нет флага готовности
   128: 000136   CFFE  RJMP	uart_snt 	; ждем готовности - флага UDRE
   129:  
   130: 000137   B90C  OUT	UDR, R16	; шлем байт
   131: 000138   9508  RET
   132: 
   133: ;|---------------------------------------------------------------------------
   134: ;| Процедура преобразования времени в ASCII
   135: ;| На входе: секунды в R10
   136: ;|            минуты в R11
   137: ;|              часы в R12
   138: ;| На выходе: В TimeInASCII и TimeInASCII+1 - Часы,
   139: ;| В TimeInASCII+3 и TimeInASCII+4 - Минуты,
   140: ;| В TimeInASCII+6 и TimeInASCII+7 - Секунды,
   141: ;| В TimeInASCII+2 и TimeInASCII+5 - Двоеточие
   142: ;|---------------------------------------------------------------------------
   143: 000139   930F  PUSH R16
   144: 	
   145: 00013A   2D0C  MOV R16,R12
   146: 00013B   9506  LSR R16
   147: 00013C   9506  LSR R16
   148: 00013D   9506  LSR R16
   149: 00013E   9506  LSR R16
   150: 00013F   5D00  SUBI R16, (-48)	; Прибавляем 48 для получения символа
   151: 000140   9300  STS TimeInASCII, R16
        000141   0060
   152: 
   153: 000142   2D0C  MOV R16,R12
   154: 000143   700F  ANDI R16,0x0F
   155: 000144   5D00  SUBI R16, (-48)	; Прибавляем 48 для получения символа
   156: 000145   9300  STS TimeInASCII+1, R16
        000146   0061
   157: 
   158: 000147   2D0B  MOV R16,R11
   159: 000148   9506  LSR R16
   160: 000149   9506  LSR R16
   161: 00014A   9506  LSR R16
   162: 00014B   9506  LSR R16
   163: 00014C   5D00  SUBI R16, (-48)	; Прибавляем 48 для получения символа
   164: 00014D   9300  STS TimeInASCII+3, R16
        00014E   0063
   165: 
   166: 00014F   2D0B  MOV R16,R11
   167: 000150   700F  ANDI R16,0x0F
   168: 000151   5D00  SUBI R16, (-48)	; Прибавляем 48 для получения символа
   169: 000152   9300  STS TimeInASCII+4, R16
        000153   0064
   170: 
   171: 000154   2D0A  MOV R16,R10
   172: 000155   9506  LSR R16
   173: 000156   9506  LSR R16
   174: 000157   9506  LSR R16
   175: 000158   9506  LSR R16
   176: 000159   5D00  SUBI R16, (-48)	; Прибавляем 48 для получения символа
   177: 00015A   9300  STS TimeInASCII+6, R16
        00015B   0066
   178: 
   179: 00015C   2D0A  MOV R16,R10
   180: 00015D   700F  ANDI R16,0x0F
   181: 00015E   5D00  SUBI R16, (-48)	; Прибавляем 48 для получения символа
   182: 00015F   9300  STS TimeInASCII+7, R16
        000160   0067
   183: 
   184: 000161   E30A  LDI R16, 0x3A
   185: 000162   9300  STS TimeInASCII+2, R16
        000163   0062
   186: 000164   9300  STS TimeInASCII+5, R16
        000165   0065
   187: 
   188: 000166   910F  POP R16
   189: 000167   9508  RET
   190: ;|---------------------------------------------------------------------------
   191: ;|                               END
   192: ;|---------------------------------------------------------------------------
   193: 
   194: ;|---------------------------------------------------------------------------
   195: ;| Процедура преобразования температуры
   196: ;| На входе: Младший байт в R22, Старший байт в R23
   197: ;| На выходе: дробная часть в R22, Целая часть со знаком в R23 (старший бит)
   198: ;|---------------------------------------------------------------------------
   199: 000168   930F  PUSH R16
   200: 000169   931F  PUSH R17
   201: 00016A   FF77  SBRS R23,7	;Если число положительное, то переходим к преобразованию дробной части
   202: 00016B   C007  rjmp IfPositiv
   203: 00016C   2700  CLR R16
   204: 00016D   2711  CLR R17
   205: 00016E   1B06  SUB R16, R22	;Переводим из дополнительного кода
   206: 00016F   0B17  SBC R17, R23
   207: 000170   2F60  MOV R22, R16
   208: 000171   2F71  MOV R23, R17
   209: 000172   6078  ORI R23,1<<3	;ставим знак "-"
   210: 
   211: IfPositiv:
   212: 000173   2F06  mov R16, R22
   213: 000174   9506  lsr R16
   214: 000175   9506  lsr R16
   215: 000176   9506  lsr R16
   216: 000177   9506  lsr R16
   217: 000178   0F77  lsl R23
   218: 000179   0F77  lsl R23
   219: 00017A   0F77  lsl R23
   220: 00017B   0F77  lsl R23
   221: 00017C   2B70  OR R23,R16	;Склеиваем целые части младшего и старшего байтов в один байт
   222: 
   223: 00017D   706F  ANDI R22,0b00001111	;Преобразуем дробную часть
   224: 00017E   2F06  mov R16, R22	;Нужно умножить на 10, для этого:
   225: 00017F   0F00  lsl R16		;Умножаем на 2
   226: 000180   0F66  lsl R22
   227: 000181   0F66  lsl R22
   228: 000182   0F66  lsl R22		;Умножаем на 8
   229: 000183   0F60  ADD R22,R16	;Складываем и умножение на 10 готово
   230: 000184   9566  lsr R22
   231: 000185   9566  lsr R22
   232: 000186   9566  lsr R22
   233: 000187   9566  lsr R22		;Делим на 16
   234: 000188   3870  CPI R23, 1<<7	;Проверка на -0, если -0.0 надо убрать минус
   235: 000189   F419  BRNE end_t_convert
   236: 00018A   2366  TST R22		;Проверка на -0.0
   237: 00018B   F409  BRNE end_t_convert
   238: 00018C   2777  CLR R23
   239: 
   240: end_t_convert:
   241: 00018D   911F  POP R17
   242: 00018E   910F  POP R16
   243: 00018F   9508  RET
   244: ;|---------------------------------------------------------------------------
   245: ;|                               END
   246: ;|---------------------------------------------------------------------------
   247: 
   248: ;|---------------------------------------------------------------------------
   249: ;| Процедура разбивки байта на десятичные разряды с преобразованием в ASCII
   250: ;| Также если 7й бит R16 = 1, то выводится знак "-"
   251: ;| На входе: целая часть в R16
   252: ;|         дробная часть в R17
   253: ;| На выходе: В NumberInASCII - старший разряд или "-",
   254: ;| в NumberInASCII+1 - средний разряд или "-",
   255: ;| в NumberInASCII+2 - младший разряд
   256: ;| в NumberInASCII+3 - символ точки
   257: ;| в NumberInASCII+4 - дробная часть
   258: ;| Также используется флаг Т
   259: ;|---------------------------------------------------------------------------
   260: 000190   94E8  CLT		;сбрасываем флаг T
   261: 000191   930F  PUSH R16
   262: 000192   932F  PUSH R18
   263: 000193   931F  PUSH R17
   264: 000194   2711  CLR R17
   265: 000195   2722  CLR R18
   266: 000196   FF07  SBRS R16,7	;Если число положительное, то переходим к преобразованию
   267: 000197   C002  rjmp not_neg
   268: 000198   9468  SET		; Число отрицательное, ставим флаг Т
   269: 000199   770F  ANDI R16, 0b01111111	; Убираем из числа знак -
   270: 00019A   3604  CPI R16, 100
   271: 00019B   F018  BRLO LoTh100 ;если меньше 100
   272: 00019C   5604  SUBI R16, 100
   273: 00019D   9523  INC R18
   274: 00019E   CFFB  RJMP not_neg
   275: 
   276: 
   277: 00019F   2322  TST R18
   278: 0001A0   F431  BRNE R1NZ ; Разряд 1 не ноль
   279: 0001A1   6012  ORI R17, 1<<1; Запоминаем что старший разряд "Пробел", вдруг пригодится :-)
   280: 0001A2   E220  LDI R18, 0x20	;Загружаем символ пробела
   281: 0001A3   9320  STS NumberInASCII, R18
        0001A4   0068
   282: 0001A5   2722  CLR R18
   283: 0001A6   C004  RJMP CalcDec
   284: 
   285: 0001A7   5D20  SUBI R18, (-48)	; Прибавляем 48 для получения символа
   286: 0001A8   9320  STS NumberInASCII, R18
        0001A9   0068
   287: 0001AA   2722  CLR R18
   288: 
   289: 0001AB   300A  CPI R16, 10	;Считаем десятки
   290: 0001AC   F018  BRLO LoTh10 ;если меньше 10
   291: 0001AD   500A  SUBI R16, 10
   292: 0001AE   9523  INC R18
   293: 0001AF   CFFB  RJMP CalcDec
   294: 
   295: 0001B0   2322  TST R18
   296: 0001B1   F441  BRNE R2NZ ; Разряд 2 не ноль
   297: 0001B2   FF11  SBRS R17,1	;Если первый регистр не 0, тогда записываем 0 а не пробел
   298: 0001B3   C006  rjmp R2NZ
   299: 
   300: 0001B4   6011  ORI R17, 1<<0; Запоминаем что средний разряд =0, вдруг пригодится :-)
   301: 0001B5   E220  LDI R18, 0x20	;Загружаем символ пробела
   302: 0001B6   9320  STS NumberInASCII+1, R18
        0001B7   0069
   303: 0001B8   2722  CLR R18
   304: 0001B9   C004  RJMP CalcOne
   305: 
   306: 0001BA   5D20  SUBI R18, (-48)	; Прибавляем 48 для получения символа
   307: 0001BB   9320  STS NumberInASCII+1, R18
        0001BC   0069
   308: 0001BD   2722  CLR R18
   309: 
   310: 0001BE   5D00  SUBI R16, (-48)	; Прибавляем 48 для получения символа
   311: 0001BF   9300  STS NumberInASCII+2, R16
        0001C0   006A
   312: 
   313: 0001C1   F45E  BRTC EndNTA	;Проверка на -, если минуса нет - заканчиваем
   314: 0001C2   FF10  SBRS R17,0	;Если второй разряд не 0, тогда записываем 0 а не пробел
   315: 0001C3   C005  rjmp R1IsZ
   316: 
   317: 0001C4   94E8  CLT
   318: 0001C5   E22D  LDI R18, 0x2D	;Загружаем символ минуса
   319: 0001C6   9320  STS NumberInASCII+1, R18	; пишем минус во второй разряд
        0001C7   0069
   320: 0001C8   C004  RJMP EndNTA
   321: 
   322: 
   323: 0001C9   94E8  CLT
   324: 0001CA   E22D  LDI R18, 0x2D	;Загружаем символ минуса
   325: 0001CB   9320  STS NumberInASCII, R18	;В первый разряд
        0001CC   0068
   326: 
   327: EndNTA:
   328: 
   329: 0001CD   911F  POP R17	;Вывод дробной части
   330: 0001CE   E22E  LDI R18, 0x2E	;Загружаем символ точки
   331: 0001CF   9320  STS NumberInASCII+3, R18	; пишем минус во второй разряд
        0001D0   006B
   332: 0001D1   5D10  SUBI R17, (-48)	; Прибавляем 48 для получения символа
   333: 0001D2   9310  STS NumberInASCII+4, R17
        0001D3   006C
   334: 
   335: 
   336: 
   337: 
   338: 0001D4   912F  POP R18
   339: 0001D5   910F  POP R16
   340: 0001D6   9508  RET
   341: ;|---------------------------------------------------------------------------
   342: ;|                               END
   343: ;|---------------------------------------------------------------------------
 -> Warning 011: C-style instructions in file, lines ignored!
 -> Warning 001: 1 symbol(s) defined, but not used!

Program             :      471 words.
Constants           :        0 words.
Total program memory:      471 words.
Eeprom space        :        0 bytes.
Data segment        :       13 bytes.
Compilation completed, no errors.
Compilation endet 24.01.2015, 23:10:49
