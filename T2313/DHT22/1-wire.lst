gavrasm Gerd's AVR assembler version 3.4 (C)2014 by DG4FAC
----------------------------------------------------------
Source file: 1-wire.asm
Hex file:    1-wire.hex
Eeprom file: 1-wire.eep
Compiled:    19.03.2015, 20:12:18
Pass:        1
     1: ;------------------------------------------------------------------------------
     2: ; http://avr-mcu.dxp.pl
     3: ; (c) Radoslaw Kwiecien, 2008
     4: ; 
     5: ; Перевод StarXXX, http://hardisoft.ru, 2009
     6: ;------------------------------------------------------------------------------
     7: 
     8: 
     9: 
    10: ;------------------------------------------------------------------------------
    11: ; Начальные установки для реализации протокола 1-Wire
    12: ;------------------------------------------------------------------------------
    13: .equ	OW_PORT	= PORTB				; Порт МК, где висит 1-Wire
    14: .equ	OW_PIN	= PINB				; Порт МК, где висит 1-Wire
    15: .equ	OW_DDR	= DDRB				; Порт МК, где висит 1-Wire
    16: .equ	OW_DQ	= PB2				; Ножка порта, где висит 1-Wire
    17: 
    18: .def	OWCount = r17				; Счетчик
    19: ;------------------------------------------------------------------------------
    20: 
    21: 
    22: ;.cseg
    23: 
    24: .include 	"wait.asm"			; Подключаем модуль временных задержек
  Including file wait.asm
     1: ;------------------------------------------------------------------------------
     2: ; Busy-wait loops utilities module
     3: ; For F_CPU >= 4MHz
     4: ; http://avr-mcu.dxp.pl
     5: ; (c) Radoslaw Kwiecien, 2008
     6: ; 
     7: ; Перевод StarXXX, http://hardisoft.ru, 2009
     8: ;------------------------------------------------------------------------------
     9: 
    10: ;------------------------------------------------------------------------------
    11: ; Модуль временных задержек
    12: ;
    13: ; !!! Для работы модуля необходимо объявить константу F_CPU равную тактовой частоте в герцах !!!
    14: ;
    15: ; !!! задержки действительны для тактовой частоты >= 4 МГц !!!
    16: 
    17: 
    18: ; задержки приблизительны! Чем больше задержка, тем точнее,
    19: ; т.е. при частоте 4МГц задержка в 1 микросекунду, учитывая время вызова подпрограммы и возврата из нее составит 2,5 микросекунды
    20: ; задержка в 10 микросекунд составит 11,5 микросекунд
    21: ; задержка в 100 мкс на самом деле будет 101,5 мкс
    22: ; тоесть, к каждой задержке добавится 1,5 мкс - это время на вызов подпрограммы и на выход из нее
    23: ;------------------------------------------------------------------------------
    24: 
    25: 
    26: 
    27: .ifndef XTAL
    28: 	.error "XTAL must be defined!"
 ===> Error Forced error: XTAL must be defined!
      Line: 	.error "XTAL must be defined!"
      File: wait.asm, Line: 28
      Syntax: .ERROR x  : forces an error with the message x
    29: .endif
    30: 
    31: 
    32: .exit XTAL < 4000000	;XTAL too low, possible wrong delay
 ===> Error 084: Undefined parameter in EXIT-directive!
      Line: .exit XTAL < 4000000	;XTAL too low, possible wrong delay
      File: wait.asm, Line: 32
      Syntax: .EXIT [x] : closes source file, x is a logical expression
    33: 
    34: .equ CYCLES_PER_US=(XTAL/1000000)	; количество такотв на микросекунду
    35: .equ C4PUS=(CYCLES_PER_US/4)		; 4 такта на одну микросекунду
    36: ;.equ DVUS(x)=(C4PUS*x)		; вычисляет величину для указанного времени в микросекундах, которую нужно передать Wait4xCycles чтобы получить желаемую задержку
    37: 
    38: ;--------------------------------------------------------------------------------------------------------------
    39: ; Подпрограмма задержки. В цикле отъедается 4 такта на каждую итерацию, кроме последней. В последней - 3 такта.
    40: ; Итого, для получения нужной задержки в микросекундах надо вызывать эту функцию предварительно
    41: ; обработав параметр макросом DVUS:
    42: ;	ldi    XH, HIGH(DVUS(500))
    43: ; 	ldi    XL, LOW(DVUS(500))
    44: ; 	rcall  Wait4xCycles ; пауза 500 микросекунд
    45: ;--------------------------------------------------------------------------------------------------------------
    46: ; Input : XH:XL - number of CPU cycles to wait (divided by four)
    47: ;--------------------------------------------------------------------------------------------------------------
    48: Wait4xCycles:
 ===> Error 017: Register value (0) out of range (R24/26/28/30!)!
      Line: 	sbiw	XH:XL, 1			; 2 такта
      File: wait.asm, Line: 49
      Syntax: SBIW parameter1,parameter2
      parameter 1: double register R24, R26, R28 or R30
      parameter 2: Constant in the range 0..63
    49: 000000   9701  sbiw	XH:XL, 1			; 2 такта
    50: 000001   F401  brne	Wait4xCycles		; 1/2
    51: 000002   9508  ret							; 4
    52: 
    53: 
    54: ;------------------------------------------------------------------------------
    55: ; Подпрограмма генерирует необходимую задержку в милисекундах
    56: ; На входе: r16 = количество милисекунд
    57: ;------------------------------------------------------------------------------
    58: ; Input : r16 - number of miliseconds to wait
    59: ;------------------------------------------------------------------------------
    60: WaitMiliseconds:
    61: 000003   930F  push 	r16
    62: WaitMsLoop: 
    63: 000004   E000  ldi    XH,HIGH(C4PUS*500)
    64: 000005   E000  ldi    XL,LOW(C4PUS*500)
    65: 000006   D000  rcall  Wait4xCycles
    66: 000007   E000  ldi    XH,HIGH(C4PUS*500)
    67: 000008   E000  ldi    XL,LOW(C4PUS*500)
    68: 000009   D000  rcall  Wait4xCycles
    69: 00000A   950A  dec    r16
    70: 00000B   F401  brne   WaitMsLoop
    71: 00000C   910F  pop    r16
    72: 00000D   9508  ret
    73: ;------------------------------------------------------------------------------
    74: ; End of file
    75: ;------------------------------------------------------------------------------
  Continuing file 1-wire.asm
    25: 
    26: 
    27: ;------------------------------------------------------------------------------
    28: ; СБРОС
    29: ; Каждая передача по протоколу 1-Wire начинается с сигнала Reset.
    30: ; После вызова этой процедуры в флаге Т регистра SGER содержится бит 
    31: ; присутствия: 1 - если на шине нет устройств, 0 - если есть
    32: ;------------------------------------------------------------------------------
    33: ; Output : T - presence bit
    34: ;------------------------------------------------------------------------------
    35: OWReset:
    36: 00000E   9800  cbi		OW_PORT,OW_DQ		; Выводим в порт 0
    37: 00000F   9A00  sbi		OW_DDR,OW_DQ		; Переключаем порт на вывод
    38: 
    39: 000010   E000  ldi		XH, HIGH(C4PUS*470)	; Ждем 470 микросекунд при придавленной в 0 линии. Это и есть импульс сброса.
    40: 000011   E000  ldi		XL, LOW(C4PUS*470)
    41: 000012   D000  rcall		Wait4xCycles
    42: 	
    43: 000013   9800  cbi		OW_DDR,OW_DQ		; Переключаем порт на ввод
    44: 
    45: 000014   E000  ldi		XH, HIGH(C4PUS*70)	; выжидаем 70 мкс (необходимое минимальное время реакции устройств на сброс)
    46: 000015   E000  ldi		XL, LOW(C4PUS*70)
    47: 000016   D000  rcall		Wait4xCycles
    48: 
    49: 000017   9468  set							; Устанавливаем флаг Т в 1
    50: 000018   9B00  sbis	OW_PIN,OW_DQ		; Если на линии после паузы осталась 1, значит устройств 1-Wire на ней нет. Пропускаем след. команду
    51: 000019   94E8  clt							; Линия была в 0 - значит на ней кто-то есть, и ответил нам импульсом PRESENCE
    52: 
    53: 00001A   E000  ldi		XH, HIGH(C4PUS*240)	; Пауза 240 мкс после сброса
    54: 00001B   E000  ldi		XL, LOW(C4PUS*240)
    55: 00001C   D000  rcall		Wait4xCycles
    56: 
    57: 00001D   9508  ret
    58: 
    59: 
    60: ;------------------------------------------------------------------------------
    61: ; ОТПРАВКА 1 БИТА
    62: ; Эта процедура отправляет 1 бит в линию 1-Wire.
    63: ; Отправляемый бит должен быть помещен в флаг С статусного регистра
    64: ;------------------------------------------------------------------------------
    65: ; Input : C - bit to write
    66: ;------------------------------------------------------------------------------
    67: OWWriteBit:
    68: 00001E   F400  brcc	OWWriteZero			; Если флаг С = 0, то переход на OWWriteZero
    69: 00001F   E000  ldi		XH, HIGH(C4PUS*1)	; Для посылки 1 линию нужно придавить в 0 всего на 1 мкс
    70: 000020   E000  ldi		XL, LOW(C4PUS*1)
    71: 000021   C000  rjmp	OWWriteOne			; переходим к отправке
    72: OWWriteZero:	
    73: 000022   E000  ldi		XH, HIGH(C4PUS*120)	; Для посылки 0 линию нужно придавить в 0 на 120 мкс
    74: 000023   E000  ldi		XL, LOW(C4PUS*120)
    75: OWWriteOne:
    76: 000024   9A00  sbi		OW_DDR, OW_DQ		; Переводим порт на выход, а там уже был 0, соответственно и линия придавливается в 0
    77: 000025   D000  rcall	Wait4xCycles		; ждем
    78: 000026   9800  cbi		OW_DDR, OW_DQ		; Переводим порт на вход
    79: 	
    80: 000027   E000  ldi		XH, HIGH(C4PUS*60)	; Должна быть пауза между таймслотами, вообще-то от 1 мкс, но здесь сделали 60 мкс
    81: 000028   E000  ldi		XL, LOW(C4PUS*60)
    82: 000029   D000  rcall	Wait4xCycles
    83: 00002A   9508  ret
    84: 
    85: 
    86: ;------------------------------------------------------------------------------
    87: ; ОТПРАВКА 1 БАЙТА
    88: ; Эта процедура отправляет 1 байт в линию 1-Wire.
    89: ; Отправляемый байт должен быть помещен в регистр r16
    90: ;------------------------------------------------------------------------------
    91: ; Input : r16 - byte to write
    92: ;------------------------------------------------------------------------------
    93: OWWriteByte:
    94: 00002B   931F  push	OWCount			; Сохраняем регистр счетчика
    95: 00002C   E010  ldi		OWCount,0		; Взводим в нём нолик
    96: 
    97: OWWriteLoop:				
    98: 00002D   9507  ror		r16				; Сдвигаем байт вправо через флаг C
    99: 00002E   D000  rcall	OWWriteBit		; отправляем в линию
   100: 00002F   9513  inc		OWCount			; увеличиваем счетчик
   101: 000030   3018  cpi		OWCount,8		; проверяем на 8
   102: 000031   F401  brne	OWWriteLoop		; если меньше - следующий бит
   103: 000032   911F  pop		OWCount			; восстанавливаем регистр-счетчик
   104: 000033   9508  ret
   105: 
   106: 
   107: 
   108: ;------------------------------------------------------------------------------
   109: ; ЧТЕНИЕ 1 БИТА
   110: ; Эта процедура читает 1 бит из линии 1-Wire.
   111: ; Принятый бит помещается в флаг С статусного регистра
   112: ;------------------------------------------------------------------------------
   113: ; Output : C - bit from slave
   114: ;------------------------------------------------------------------------------
   115: OWReadBit:
   116: 000034   E000  ldi		XH, HIGH(C4PUS*1)	; Придавливаем линию в 0 на 1 мкс
   117: 000035   E000  ldi		XL, LOW(C4PUS*1)
   118: 000036   9A00  sbi		OW_DDR, OW_DQ
   119: 000037   D000  rcall	Wait4xCycles
   120: 
   121: 000038   9800  cbi		OW_DDR, OW_DQ		; Переводим порт на чтение
   122: 000039   E000  ldi		XH, HIGH(C4PUS*5)	; ждем 5 мкс
   123: 00003A   E000  ldi		XL, LOW(C4PUS*5)
   124: 00003B   D000  rcall	Wait4xCycles
   125: 
   126: 00003C   94E8  clt							; Сбрасываем флаг Т
   127: 00003D   9900  sbic	OW_PIN,OW_DQ		; Если на линии 0 - то пропускаем следующую команду
   128: 00003E   9468  set
   129: 
   130: 								; Итак, сейчас в регистре Т полученный бит
   131: 
   132: 00003F   E000  ldi		XH, HIGH(C4PUS*50)	; выжидаем 50 мкс для окончания таймслота
   133: 000040   E000  ldi		XL, LOW(C4PUS*50)
   134: 000041   D000  rcall	Wait4xCycles
   135: 								; переносим флаг Т в флаг С
   136: 000042   9408  sec
   137: 000043   F006  brts	OWReadBitEnd
   138: 000044   9488  clc
   139: 
   140: OWReadBitEnd:
   141: 000045   9508  ret
   142: 
   143: 
   144: 
   145: ;------------------------------------------------------------------------------
   146: ; ЧТЕНИЕ 1 БАЙТА
   147: ; Эта процедура читает 1 байт из линии 1-Wire.
   148: ; Принятый байт помещается регистр r16
   149: ;------------------------------------------------------------------------------
   150: ; Output : r16 - byte from slave
   151: ;------------------------------------------------------------------------------
   152: OWReadByte:
   153: 000046   931F  push	OWCount			; Сохраняем регистр-счетчик
   154: 000047   E010  ldi		OWCount,0		; и обнуляем его
   155: OWReadLoop:
   156: 000048   D000  rcall	OWReadBit		; читаем бит
   157: 000049   9507  ror		r16				; запихиваем его в r16 сдвигом вправо из флага С
   158: 00004A   9513  inc		OWCount			; увеличиваем счетчик
   159: 00004B   3018  cpi		OWCount,8		; уже 8?
   160: 00004C   F401  brne	OWReadLoop		; нет - продолжаем считывать
   161: 00004D   911F  pop		OWCount			; восстанавливаем регистр-счетчик
   162: 00004E   9508  ret
   163: ;------------------------------------------------------------------------------
   164: ;
   165: ;------------------------------------------------------------------------------
   166: 
   167: 
   168: 
   169: 
   170: 
   171: ;.include 	"1-Wire Search.asm"		; Подключаем модуль поиска устройств на шине 1-Wire
   172: 
   173: 
   174: 
   175: 
Compilation aborted, 3 errors!
