gavrasm Gerd's AVR assembler version 3.4 (C)2014 by DG4FAC
----------------------------------------------------------
Source file: ish.asm
Hex file:    ish.hex
Eeprom file: ish.eep
Compiled:    20.03.2015, 14:46:20
Pass:        2
     1: .include "/home/marik/Project/tn2313Adef.inc"
  Including file /home/marik/Project/tn2313Adef.inc
     1: ;***** THIS IS A MACHINE GENERATED FILE - DO NOT EDIT ********************
     2: ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny2313A.xml *********
     3: ;*************************************************************************
     4: ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
     5: ;* 
     6: ;* Number            : AVR000
     7: ;* File Name         : "tn2313Adef.inc"
     8: ;* Title             : Register/Bit Definitions for the ATtiny2313A
     9: ;* Date              : 2011-02-09
    10: ;* Version           : 2.35
    11: ;* Support E-mail    : avr@atmel.com
    12: ;* Target MCU        : ATtiny2313A
    13: ;* 
    14: ;* DESCRIPTION
    15: ;* When including this file in the assembly program file, all I/O register 
    16: ;* names and I/O register bit names appearing in the data book can be used.
    17: ;* In addition, the six registers forming the three data pointers X, Y and 
    18: ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
    19: ;* SRAM is also defined 
    20: ;* 
    21: ;* The Register names are represented by their hexadecimal address.
    22: ;* 
    23: ;* The Register Bit names are represented by their bit number (0-7).
    24: ;* 
    25: ;* Please observe the difference in using the bit names with instructions
    26: ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
    27: ;* (skip if bit in register set/cleared). The following example illustrates
    28: ;* this:
    29: ;* 
    30: ;* in    r16,PORTB             ;read PORTB latch
    31: ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
    32: ;* out   PORTB,r16             ;output to PORTB
    33: ;* 
    34: ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
    35: ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
    36: ;* rjmp  TOV0_is_set           ;jump if set
    37: ;* ...                         ;otherwise do something else
    38: ;*************************************************************************
    39: 
    40: #ifndef _TN2313ADEF_INC_
    41: #define _TN2313ADEF_INC_
    42: 
    43: 
    44: #pragma partinc 0
    45: 
    46: ; ***** SPECIFY DEVICE ***************************************************
    47: .device ATtiny2313A
    48: #pragma AVRPART ADMIN PART_NAME ATtiny2313A
    49: .equ	SIGNATURE_000	= 0x1e
    50: .equ	SIGNATURE_001	= 0x91
    51: .equ	SIGNATURE_002	= 0x0a
    52: 
    53: #pragma AVRPART CORE CORE_VERSION V2
    54: #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
    55: 
    56: 
    57: ; ***** I/O REGISTER DEFINITIONS *****************************************
    58: ; NOTE:
    59: ; Definitions marked "MEMORY MAPPED"are extended I/O ports
    60: ; and cannot be used with IN/OUT instructions
    61: .equ	SREG	= 0x3f
    62: .equ	SPL	= 0x3d
    63: .equ	OCR0B	= 0x3c
    64: .equ	GIMSK	= 0x3b
    65: .equ	EIFR	= 0x3a
    66: .equ	TIMSK	= 0x39
    67: .equ	TIFR	= 0x38
    68: .equ	SPMCSR	= 0x37
    69: .equ	OCR0A	= 0x36
    70: .equ	MCUCR	= 0x35
    71: .equ	MCUSR	= 0x34
    72: .equ	TCCR0B	= 0x33
    73: .equ	TCNT0	= 0x32
    74: .equ	OSCCAL	= 0x31
    75: .equ	TCCR0A	= 0x30
    76: .equ	TCCR1A	= 0x2f
    77: .equ	TCCR1B	= 0x2e
    78: .equ	TCNT1L	= 0x2c
    79: .equ	TCNT1H	= 0x2d
    80: .equ	OCR1AL	= 0x2a
    81: .equ	OCR1AH	= 0x2b
    82: .equ	OCR1BL	= 0x28
    83: .equ	OCR1BH	= 0x29
    84: .equ	CLKPR	= 0x26
    85: .equ	ICR1L	= 0x24
    86: .equ	ICR1H	= 0x25
    87: .equ	GTCCR	= 0x23
    88: .equ	TCCR1C	= 0x22
    89: .equ	WDTCR	= 0x21
    90: .equ	PCMSK	= 0x20
    91: .equ	EEAR	= 0x1e
    92: .equ	EEDR	= 0x1d
    93: .equ	EECR	= 0x1c
    94: .equ	PORTA	= 0x1b
    95: .equ	DDRA	= 0x1a
    96: .equ	PINA	= 0x19
    97: .equ	PORTB	= 0x18
    98: .equ	DDRB	= 0x17
    99: .equ	PINB	= 0x16
   100: .equ	GPIOR2	= 0x15
   101: .equ	GPIOR1	= 0x14
   102: .equ	GPIOR0	= 0x13
   103: .equ	PORTD	= 0x12
   104: .equ	DDRD	= 0x11
   105: .equ	PIND	= 0x10
   106: .equ	USIDR	= 0x0f
   107: .equ	USISR	= 0x0e
   108: .equ	USICR	= 0x0d
   109: .equ	UDR	= 0x0c
   110: .equ	UCSRA	= 0x0b
   111: .equ	UCSRB	= 0x0a
   112: .equ	UBRRL	= 0x09
   113: .equ	ACSR	= 0x08
   114: .equ	BODCR	= 0x07
   115: .equ	PRR	= 0x06
   116: .equ	PCMSK2	= 0x05
   117: .equ	PCMSK1	= 0x04
   118: .equ	UCSRC	= 0x03
   119: .equ	UBRRH	= 0x02
   120: .equ	DIDR	= 0x01
   121: 
   122: 
   123: ; ***** BIT DEFINITIONS **************************************************
   124: 
   125: ; ***** PORTB ************************
   126: ; PORTB - Port B Data Register
   127: .equ	PORTB0	= 0	; Port B Data Register bit 0
   128: .equ	PB0	= 0	; For compatibility
   129: .equ	PORTB1	= 1	; Port B Data Register bit 1
   130: .equ	PB1	= 1	; For compatibility
   131: .equ	PORTB2	= 2	; Port B Data Register bit 2
   132: .equ	PB2	= 2	; For compatibility
   133: .equ	PORTB3	= 3	; Port B Data Register bit 3
   134: .equ	PB3	= 3	; For compatibility
   135: .equ	PORTB4	= 4	; Port B Data Register bit 4
   136: .equ	PB4	= 4	; For compatibility
   137: .equ	PORTB5	= 5	; Port B Data Register bit 5
   138: .equ	PB5	= 5	; For compatibility
   139: .equ	PORTB6	= 6	; Port B Data Register bit 6
   140: .equ	PB6	= 6	; For compatibility
   141: .equ	PORTB7	= 7	; Port B Data Register bit 7
   142: .equ	PB7	= 7	; For compatibility
   143: 
   144: ; DDRB - Port B Data Direction Register
   145: .equ	DDB0	= 0	; Port B Data Direction Register bit 0
   146: .equ	DDB1	= 1	; Port B Data Direction Register bit 1
   147: .equ	DDB2	= 2	; Port B Data Direction Register bit 2
   148: .equ	DDB3	= 3	; Port B Data Direction Register bit 3
   149: .equ	DDB4	= 4	; Port B Data Direction Register bit 4
   150: .equ	DDB5	= 5	; Port B Data Direction Register bit 5
   151: .equ	DDB6	= 6	; Port B Data Direction Register bit 6
   152: .equ	DDB7	= 7	; Port B Data Direction Register bit 7
   153: 
   154: ; PINB - Port B Input Pins
   155: .equ	PINB0	= 0	; Port B Input Pins bit 0
   156: .equ	PINB1	= 1	; Port B Input Pins bit 1
   157: .equ	PINB2	= 2	; Port B Input Pins bit 2
   158: .equ	PINB3	= 3	; Port B Input Pins bit 3
   159: .equ	PINB4	= 4	; Port B Input Pins bit 4
   160: .equ	PINB5	= 5	; Port B Input Pins bit 5
   161: .equ	PINB6	= 6	; Port B Input Pins bit 6
   162: .equ	PINB7	= 7	; Port B Input Pins bit 7
   163: 
   164: 
   165: ; ***** TIMER_COUNTER_0 **************
   166: ; TIMSK - Timer/Counter Interrupt Mask Register
   167: .equ	OCIE0A	= 0	; Timer/Counter0 Output Compare Match A Interrupt Enable
   168: .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
   169: .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
   170: 
   171: ; TIFR - Timer/Counter Interrupt Flag register
   172: .equ	OCF0A	= 0	; Timer/Counter0 Output Compare Flag 0A
   173: .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
   174: .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
   175: 
   176: ; OCR0B - Timer/Counter0 Output Compare Register
   177: .equ	OCR0_0	= 0	; 
   178: .equ	OCR0_1	= 1	; 
   179: .equ	OCR0_2	= 2	; 
   180: .equ	OCR0_3	= 3	; 
   181: .equ	OCR0_4	= 4	; 
   182: .equ	OCR0_5	= 5	; 
   183: .equ	OCR0_6	= 6	; 
   184: .equ	OCR0_7	= 7	; 
   185: 
   186: ; OCR0A - Timer/Counter0 Output Compare Register
   187: .equ	OCR0A_0	= 0	; 
   188: .equ	OCR0A_1	= 1	; 
   189: .equ	OCR0A_2	= 2	; 
   190: .equ	OCR0A_3	= 3	; 
   191: .equ	OCR0A_4	= 4	; 
   192: .equ	OCR0A_5	= 5	; 
   193: .equ	OCR0A_6	= 6	; 
   194: .equ	OCR0A_7	= 7	; 
   195: 
   196: ; TCCR0A - Timer/Counter  Control Register A
   197: .equ	WGM00	= 0	; Waveform Generation Mode
   198: .equ	WGM01	= 1	; Waveform Generation Mode
   199: .equ	COM0B0	= 4	; Compare Match Output B Mode
   200: .equ	COM0B1	= 5	; Compare Match Output B Mode
   201: .equ	COM0A0	= 6	; Compare Match Output A Mode
   202: .equ	COM0A1	= 7	; Compare Match Output A Mode
   203: 
   204: ; TCNT0 - Timer/Counter0
   205: .equ	TCNT0_0	= 0	; 
   206: .equ	TCNT0_1	= 1	; 
   207: .equ	TCNT0_2	= 2	; 
   208: .equ	TCNT0_3	= 3	; 
   209: .equ	TCNT0_4	= 4	; 
   210: .equ	TCNT0_5	= 5	; 
   211: .equ	TCNT0_6	= 6	; 
   212: .equ	TCNT0_7	= 7	; 
   213: 
   214: ; TCCR0B - Timer/Counter Control Register B
   215: .equ	TCCR0	= TCCR0B	; For compatibility
   216: .equ	CS00	= 0	; Clock Select
   217: .equ	CS01	= 1	; Clock Select
   218: .equ	CS02	= 2	; Clock Select
   219: .equ	WGM02	= 3	; 
   220: .equ	FOC0B	= 6	; Force Output Compare B
   221: .equ	FOC0A	= 7	; Force Output Compare B
   222: 
   223: 
   224: ; ***** TIMER_COUNTER_1 **************
   225: ; TIMSK - Timer/Counter Interrupt Mask Register
   226: .equ	ICIE1	= 3	; Timer/Counter1 Input Capture Interrupt Enable
   227: .equ	TICIE	= ICIE1	; For compatibility
   228: .equ	OCIE1B	= 5	; Timer/Counter1 Output CompareB Match Interrupt Enable
   229: .equ	OCIE1A	= 6	; Timer/Counter1 Output CompareA Match Interrupt Enable
   230: .equ	TOIE1	= 7	; Timer/Counter1 Overflow Interrupt Enable
   231: 
   232: ; TIFR - Timer/Counter Interrupt Flag register
   233: .equ	ICF1	= 3	; Input Capture Flag 1
   234: .equ	OCF1B	= 5	; Output Compare Flag 1B
   235: .equ	OCF1A	= 6	; Output Compare Flag 1A
   236: .equ	TOV1	= 7	; Timer/Counter1 Overflow Flag
   237: 
   238: ; TCCR1A - Timer/Counter1 Control Register A
   239: .equ	WGM10	= 0	; Pulse Width Modulator Select Bit 0
   240: .equ	PWM10	= WGM10	; For compatibility
   241: .equ	WGM11	= 1	; Pulse Width Modulator Select Bit 1
   242: .equ	PWM11	= WGM11	; For compatibility
   243: .equ	COM1B0	= 4	; Comparet Ouput Mode 1B, bit 0
   244: .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
   245: .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
   246: .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
   247: 
   248: ; TCCR1B - Timer/Counter1 Control Register B
   249: .equ	CS10	= 0	; Clock Select bit 0
   250: .equ	CS11	= 1	; Clock Select 1 bit 1
   251: .equ	CS12	= 2	; Clock Select1 bit 2
   252: .equ	WGM12	= 3	; Waveform Generation Mode Bit 2
   253: .equ	CTC1	= WGM12	; For compatibility
   254: .equ	WGM13	= 4	; Waveform Generation Mode Bit 3
   255: .equ	ICES1	= 6	; Input Capture 1 Edge Select
   256: .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
   257: 
   258: ; TCCR1C - Timer/Counter1 Control Register C
   259: .equ	FOC1B	= 6	; Force Output Compare for Channel B
   260: .equ	FOC1A	= 7	; Force Output Compare for Channel A
   261: 
   262: 
   263: ; ***** WATCHDOG *********************
   264: ; WDTCR - Watchdog Timer Control Register
   265: .equ	WDTCSR	= WDTCR	; For compatibility
   266: .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
   267: .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
   268: .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
   269: .equ	WDE	= 3	; Watch Dog Enable
   270: .equ	WDCE	= 4	; Watchdog Change Enable
   271: .equ	WDTOE	= WDCE	; For compatibility
   272: .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
   273: .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
   274: .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
   275: 
   276: 
   277: ; ***** USART ************************
   278: ; UDR - USART I/O Data Register
   279: .equ	UDR0	= 0	; USART I/O Data Register bit 0
   280: .equ	UDR1	= 1	; USART I/O Data Register bit 1
   281: .equ	UDR2	= 2	; USART I/O Data Register bit 2
   282: .equ	UDR3	= 3	; USART I/O Data Register bit 3
   283: .equ	UDR4	= 4	; USART I/O Data Register bit 4
   284: .equ	UDR5	= 5	; USART I/O Data Register bit 5
   285: .equ	UDR6	= 6	; USART I/O Data Register bit 6
   286: .equ	UDR7	= 7	; USART I/O Data Register bit 7
   287: 
   288: ; UCSRA - USART Control and Status Register A
   289: .equ	USR	= UCSRA	; For compatibility
   290: .equ	MPCM	= 0	; Multi-processor Communication Mode
   291: .equ	U2X	= 1	; Double the USART Transmission Speed
   292: .equ	UPE	= 2	; USART Parity Error
   293: .equ	PE	= UPE	; For compatibility
   294: .equ	DOR	= 3	; Data overRun
   295: .equ	FE	= 4	; Framing Error
   296: .equ	UDRE	= 5	; USART Data Register Empty
   297: .equ	TXC	= 6	; USART Transmitt Complete
   298: .equ	RXC	= 7	; USART Receive Complete
   299: 
   300: ; UCSRB - USART Control and Status Register B
   301: .equ	UCR	= UCSRB	; For compatibility
   302: .equ	TXB8	= 0	; Transmit Data Bit 8
   303: .equ	RXB8	= 1	; Receive Data Bit 8
   304: .equ	UCSZ2	= 2	; Character Size
   305: .equ	CHR9	= UCSZ2	; For compatibility
   306: .equ	TXEN	= 3	; Transmitter Enable
   307: .equ	RXEN	= 4	; Receiver Enable
   308: .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
   309: .equ	TXCIE	= 6	; TX Complete Interrupt Enable
   310: .equ	RXCIE	= 7	; RX Complete Interrupt Enable
   311: 
   312: ; UCSRC - USART Control and Status Register C
   313: .equ	UCPOL	= 0	; Clock Polarity
   314: .equ	UCSZ0	= 1	; Character Size Bit 0
   315: .equ	UCSZ1	= 2	; Character Size Bit 1
   316: .equ	USBS	= 3	; Stop Bit Select
   317: .equ	UPM0	= 4	; Parity Mode Bit 0
   318: .equ	UPM1	= 5	; Parity Mode Bit 1
   319: .equ	UMSEL	= 6	; USART Mode Select
   320: 
   321: .equ	UBRR	= UBRRL	; For compatibility
   322: 
   323: ; ***** ANALOG_COMPARATOR ************
   324: ; ACSR - Analog Comparator Control And Status Register
   325: .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
   326: .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
   327: .equ	ACIC	= 2	; 
   328: .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
   329: .equ	ACI	= 4	; Analog Comparator Interrupt Flag
   330: .equ	ACO	= 5	; Analog Compare Output
   331: .equ	ACBG	= 6	; Analog Comparator Bandgap Select
   332: .equ	ACD	= 7	; Analog Comparator Disable
   333: 
   334: ; DIDR - Digital Input Disable Register 1
   335: .equ	AIN0D	= 0	; AIN0 Digital Input Disable
   336: .equ	AIN1D	= 1	; AIN1 Digital Input Disable
   337: 
   338: 
   339: ; ***** PORTD ************************
   340: ; PORTD - Data Register, Port D
   341: .equ	PORTD0	= 0	; 
   342: .equ	PD0	= 0	; For compatibility
   343: .equ	PORTD1	= 1	; 
   344: .equ	PD1	= 1	; For compatibility
   345: .equ	PORTD2	= 2	; 
   346: .equ	PD2	= 2	; For compatibility
   347: .equ	PORTD3	= 3	; 
   348: .equ	PD3	= 3	; For compatibility
   349: .equ	PORTD4	= 4	; 
   350: .equ	PD4	= 4	; For compatibility
   351: .equ	PORTD5	= 5	; 
   352: .equ	PD5	= 5	; For compatibility
   353: .equ	PORTD6	= 6	; 
   354: .equ	PD6	= 6	; For compatibility
   355: 
   356: ; DDRD - Data Direction Register, Port D
   357: .equ	DDD0	= 0	; 
   358: .equ	DDD1	= 1	; 
   359: .equ	DDD2	= 2	; 
   360: .equ	DDD3	= 3	; 
   361: .equ	DDD4	= 4	; 
   362: .equ	DDD5	= 5	; 
   363: .equ	DDD6	= 6	; 
   364: 
   365: ; PIND - Input Pins, Port D
   366: .equ	PIND0	= 0	; 
   367: .equ	PIND1	= 1	; 
   368: .equ	PIND2	= 2	; 
   369: .equ	PIND3	= 3	; 
   370: .equ	PIND4	= 4	; 
   371: .equ	PIND5	= 5	; 
   372: .equ	PIND6	= 6	; 
   373: 
   374: 
   375: ; ***** EEPROM ***********************
   376: ; EEAR - EEPROM Read/Write Access
   377: .equ	EEARL	= EEAR	; For compatibility
   378: .equ	EEAR0	= 0	; EEPROM Read/Write Access bit 0
   379: .equ	EEAR1	= 1	; EEPROM Read/Write Access bit 1
   380: .equ	EEAR2	= 2	; EEPROM Read/Write Access bit 2
   381: .equ	EEAR3	= 3	; EEPROM Read/Write Access bit 3
   382: .equ	EEAR4	= 4	; EEPROM Read/Write Access bit 4
   383: .equ	EEAR5	= 5	; EEPROM Read/Write Access bit 5
   384: .equ	EEAR6	= 6	; EEPROM Read/Write Access bit 6
   385: 
   386: ; EEDR - EEPROM Data Register
   387: .equ	EEDR0	= 0	; EEPROM Data Register bit 0
   388: .equ	EEDR1	= 1	; EEPROM Data Register bit 1
   389: .equ	EEDR2	= 2	; EEPROM Data Register bit 2
   390: .equ	EEDR3	= 3	; EEPROM Data Register bit 3
   391: .equ	EEDR4	= 4	; EEPROM Data Register bit 4
   392: .equ	EEDR5	= 5	; EEPROM Data Register bit 5
   393: .equ	EEDR6	= 6	; EEPROM Data Register bit 6
   394: .equ	EEDR7	= 7	; EEPROM Data Register bit 7
   395: 
   396: ; EECR - EEPROM Control Register
   397: .equ	EERE	= 0	; EEPROM Read Enable
   398: .equ	EEPE	= 1	; EEPROM Write Enable
   399: .equ	EEWE	= EEPE	; For compatibility
   400: .equ	EEMPE	= 2	; EEPROM Master Write Enable
   401: .equ	EEMWE	= EEMPE	; For compatibility
   402: .equ	EERIE	= 3	; EEProm Ready Interrupt Enable
   403: .equ	EEPM0	= 4	; 
   404: .equ	EEPM1	= 5	; 
   405: 
   406: 
   407: ; ***** PORTA ************************
   408: ; PORTA - Port A Data Register
   409: .equ	PORTA0	= 0	; Port A Data Register bit 0
   410: .equ	PA0	= 0	; For compatibility
   411: .equ	PORTA1	= 1	; Port A Data Register bit 1
   412: .equ	PA1	= 1	; For compatibility
   413: .equ	PORTA2	= 2	; Port A Data Register bit 2
   414: .equ	PA2	= 2	; For compatibility
   415: 
   416: ; DDRA - Port A Data Direction Register
   417: .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
   418: .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
   419: .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
   420: 
   421: ; PINA - Port A Input Pins
   422: .equ	PINA0	= 0	; Input Pins, Port A bit 0
   423: .equ	PINA1	= 1	; Input Pins, Port A bit 1
   424: .equ	PINA2	= 2	; Input Pins, Port A bit 2
   425: 
   426: 
   427: ; ***** USI **************************
   428: ; USIDR - USI Data Register
   429: .equ	USIDR0	= 0	; USI Data Register bit 0
   430: .equ	USIDR1	= 1	; USI Data Register bit 1
   431: .equ	USIDR2	= 2	; USI Data Register bit 2
   432: .equ	USIDR3	= 3	; USI Data Register bit 3
   433: .equ	USIDR4	= 4	; USI Data Register bit 4
   434: .equ	USIDR5	= 5	; USI Data Register bit 5
   435: .equ	USIDR6	= 6	; USI Data Register bit 6
   436: .equ	USIDR7	= 7	; USI Data Register bit 7
   437: 
   438: ; USISR - USI Status Register
   439: .equ	USICNT0	= 0	; USI Counter Value Bit 0
   440: .equ	USICNT1	= 1	; USI Counter Value Bit 1
   441: .equ	USICNT2	= 2	; USI Counter Value Bit 2
   442: .equ	USICNT3	= 3	; USI Counter Value Bit 3
   443: .equ	USIDC	= 4	; Data Output Collision
   444: .equ	USIPF	= 5	; Stop Condition Flag
   445: .equ	USIOIF	= 6	; Counter Overflow Interrupt Flag
   446: .equ	USISIF	= 7	; Start Condition Interrupt Flag
   447: 
   448: ; USICR - USI Control Register
   449: .equ	USITC	= 0	; Toggle Clock Port Pin
   450: .equ	USICLK	= 1	; Clock Strobe
   451: .equ	USICS0	= 2	; USI Clock Source Select Bit 0
   452: .equ	USICS1	= 3	; USI Clock Source Select Bit 1
   453: .equ	USIWM0	= 4	; USI Wire Mode Bit 0
   454: .equ	USIWM1	= 5	; USI Wire Mode Bit 1
   455: .equ	USIOIE	= 6	; Counter Overflow Interrupt Enable
   456: .equ	USISIE	= 7	; Start Condition Interrupt Enable
   457: 
   458: 
   459: ; ***** EXTERNAL_INTERRUPT ***********
   460: ; GIMSK - General Interrupt Mask Register
   461: .equ	PCIE	= 5	; 
   462: .equ	INT0	= 6	; External Interrupt Request 0 Enable
   463: .equ	INT1	= 7	; External Interrupt Request 1 Enable
   464: 
   465: ; EIFR - Extended Interrupt Flag Register
   466: .equ	GIFR	= EIFR	; For compatibility
   467: .equ	PCIF	= 5	; 
   468: .equ	INTF0	= 6	; External Interrupt Flag 0
   469: .equ	INTF1	= 7	; External Interrupt Flag 1
   470: 
   471: ; PCMSK2 - Pin Change Interrupt Mask Register 2
   472: .equ	PCINT11	= 0	; Pin Change Interrupt Mask 11
   473: .equ	PCINT12	= 1	; Pin Change Interrupt Mask 12
   474: .equ	PCINT13	= 2	; Pin Change Interrupt Mask 13
   475: .equ	PCINT14	= 3	; Pin Change Interrupt Mask 14
   476: .equ	PCINT15	= 4	; Pin Change Interrupt Mask 15
   477: .equ	PCINT16	= 5	; Pin Change Interrupt Mask 16
   478: .equ	PCINT17	= 6	; Pin Change Interrupt Mask 17
   479: 
   480: ; PCMSK1 - Pin Change Interrupt Mask Register 1
   481: .equ	PCINT8	= 0	; Pin Change Interrupt Mask 8
   482: .equ	PCINT9	= 1	; Pin Change Interrupt Mask 9
   483: .equ	PCINT10	= 2	; Pin Change Interrupt Mask 10
   484: 
   485: 
   486: ; ***** CPU **************************
   487: ; SREG - Status Register
   488: .equ	SREG_C	= 0	; Carry Flag
   489: .equ	SREG_Z	= 1	; Zero Flag
   490: .equ	SREG_N	= 2	; Negative Flag
   491: .equ	SREG_V	= 3	; Two's Complement Overflow Flag
   492: .equ	SREG_S	= 4	; Sign Bit
   493: .equ	SREG_H	= 5	; Half Carry Flag
   494: .equ	SREG_T	= 6	; Bit Copy Storage
   495: .equ	SREG_I	= 7	; Global Interrupt Enable
   496: 
   497: ; SPMCSR - Store Program Memory Control and Status register
   498: .equ	SPMEN	= 0	; Store Program Memory Enable
   499: .equ	PGERS	= 1	; Page Erase
   500: .equ	PGWRT	= 2	; Page Write
   501: .equ	RFLB	= 3	; Read Fuse and Lock Bits
   502: .equ	CTPB	= 4	; Clear Temporary Page Buffer
   503: 
   504: ; MCUCR - MCU Control Register
   505: .equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
   506: .equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
   507: .equ	ISC10	= 2	; Interrupt Sense Control 1 bit 0
   508: .equ	ISC11	= 3	; Interrupt Sense Control 1 bit 1
   509: .equ	SM0	= 4	; Sleep Mode Select Bit 0
   510: .equ	SM	= SM0	; For compatibility
   511: .equ	SE	= 5	; Sleep Enable
   512: .equ	SM1	= 6	; Sleep Mode Select Bit 1
   513: .equ	PUD	= 7	; Pull-up Disable
   514: 
   515: ; CLKPR - Clock Prescale Register
   516: .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
   517: .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
   518: .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
   519: .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
   520: .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
   521: 
   522: ; MCUSR - MCU Status register
   523: .equ	PORF	= 0	; Power-On Reset Flag
   524: .equ	EXTRF	= 1	; External Reset Flag
   525: .equ	BORF	= 2	; Brown-out Reset Flag
   526: .equ	WDRF	= 3	; Watchdog Reset Flag
   527: 
   528: ; OSCCAL - Oscillator Calibration Register
   529: .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
   530: .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
   531: .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
   532: .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
   533: .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
   534: .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
   535: .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
   536: 
   537: ; GTCCR - General Timer Counter Control Register
   538: .equ	SFIOR	= GTCCR	; For compatibility
   539: .equ	PSR10	= 0	; 
   540: 
   541: ; PCMSK - Pin-Change Mask register
   542: .equ	PCINT0	= 0	; Pin-Change Interrupt 0
   543: .equ	PCINT1	= 1	; Pin-Change Interrupt 1
   544: .equ	PCINT2	= 2	; Pin-Change Interrupt 2
   545: .equ	PCINT3	= 3	; Pin-Change Interrupt 3
   546: .equ	PCINT4	= 4	; Pin-Change Interrupt 4
   547: .equ	PCINT5	= 5	; Pin-Change Interrupt 5
   548: .equ	PCINT6	= 6	; Pin-Change Interrupt 6
   549: .equ	PCINT7	= 7	; Pin-Change Interrupt 7
   550: 
   551: ; GPIOR2 - General Purpose I/O Register 2
   552: .equ	GPIOR20	= 0	; General Purpose I/O Register 2 bit 0
   553: .equ	GPIOR21	= 1	; General Purpose I/O Register 2 bit 1
   554: .equ	GPIOR22	= 2	; General Purpose I/O Register 2 bit 2
   555: .equ	GPIOR23	= 3	; General Purpose I/O Register 2 bit 3
   556: .equ	GPIOR24	= 4	; General Purpose I/O Register 2 bit 4
   557: .equ	GPIOR25	= 5	; General Purpose I/O Register 2 bit 5
   558: .equ	GPIOR26	= 6	; General Purpose I/O Register 2 bit 6
   559: .equ	GPIOR27	= 7	; General Purpose I/O Register 2 bit 7
   560: 
   561: ; GPIOR1 - General Purpose I/O Register 1
   562: .equ	GPIOR10	= 0	; General Purpose I/O Register 1 bit 0
   563: .equ	GPIOR11	= 1	; General Purpose I/O Register 1 bit 1
   564: .equ	GPIOR12	= 2	; General Purpose I/O Register 1 bit 2
   565: .equ	GPIOR13	= 3	; General Purpose I/O Register 1 bit 3
   566: .equ	GPIOR14	= 4	; General Purpose I/O Register 1 bit 4
   567: .equ	GPIOR15	= 5	; General Purpose I/O Register 1 bit 5
   568: .equ	GPIOR16	= 6	; General Purpose I/O Register 1 bit 6
   569: .equ	GPIOR17	= 7	; General Purpose I/O Register 1 bit 7
   570: 
   571: ; GPIOR0 - General Purpose I/O Register 0
   572: .equ	GPIOR00	= 0	; General Purpose I/O Register 0 bit 0
   573: .equ	GPIOR01	= 1	; General Purpose I/O Register 0 bit 1
   574: .equ	GPIOR02	= 2	; General Purpose I/O Register 0 bit 2
   575: .equ	GPIOR03	= 3	; General Purpose I/O Register 0 bit 3
   576: .equ	GPIOR04	= 4	; General Purpose I/O Register 0 bit 4
   577: .equ	GPIOR05	= 5	; General Purpose I/O Register 0 bit 5
   578: .equ	GPIOR06	= 6	; General Purpose I/O Register 0 bit 6
   579: .equ	GPIOR07	= 7	; General Purpose I/O Register 0 bit 7
   580: 
   581: ; PRR - Power reduction register
   582: .equ	PRUSART	= 0	; 
   583: .equ	PRUSI	= 1	; 
   584: .equ	PRTIM0	= 2	; 
   585: .equ	PRTIM1	= 3	; 
   586: 
   587: ; BODCR - BOD control register
   588: .equ	BPDSE	= 0	; 
   589: .equ	BPDS	= 1	; 
   590: 
   591: 
   592: 
   593: ; ***** LOCKSBITS ********************************************************
   594: .equ	LB1	= 0	; Lockbit
   595: .equ	LB2	= 1	; Lockbit
   596: 
   597: 
   598: ; ***** FUSES ************************************************************
   599: ; LOW fuse bits
   600: .equ	CKSEL0	= 0	; Select Clock Source
   601: .equ	CKSEL1	= 1	; Select Clock Source
   602: .equ	CKSEL2	= 2	; Select Clock Source
   603: .equ	CKSEL3	= 3	; Select Clock Source
   604: .equ	SUT0	= 4	; Select start-up time
   605: .equ	SUT1	= 5	; Select start-up time
   606: .equ	CKOUT	= 6	; Clock output
   607: .equ	CKDIV8	= 7	; Divide clock by 8
   608: 
   609: ; HIGH fuse bits
   610: .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
   611: .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
   612: .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
   613: .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
   614: .equ	WDTON	= 4	; Watchdog Timer Always On
   615: .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
   616: .equ	DWEN	= 6	; debugWIRE Enable
   617: .equ	RSTDISBL	= 7	; External reset disable
   618: 
   619: ; EXTENDED fuse bits
   620: .equ	SELFPRGEN	= 0	; Self Programming Enable
   621: 
   622: 
   623: 
   624: ; ***** CPU REGISTER DEFINITIONS *****************************************
   625: .def	XH	= r27
   626: .def	XL	= r26
   627: .def	YH	= r29
   628: .def	YL	= r28
   629: .def	ZH	= r31
   630: .def	ZL	= r30
   631: 
   632: 
   633: 
   634: ; ***** DATA MEMORY DECLARATIONS *****************************************
   635: .equ	FLASHEND	= 0x03ff	; Note: Word address
   636: .equ	IOEND	= 0x003f
   637: .equ	SRAM_START	= 0x0060
   638: .equ	SRAM_SIZE	= 128
   639: .equ	RAMEND	= 0x00df
   640: .equ	XRAMEND	= 0x0000
   641: .equ	E2END	= 0x007f
   642: .equ	EEPROMEND	= 0x007f
   643: .equ	EEADRBITS	= 7
   644: #pragma AVRPART MEMORY PROG_FLASH 2048
   645: #pragma AVRPART MEMORY EEPROM 128
   646: #pragma AVRPART MEMORY INT_SRAM SIZE 128
   647: #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
   648: 
   649: 
   650: 
   651: ; ***** BOOTLOADER DECLARATIONS ******************************************
   652: .equ	NRWW_START_ADDR	= 0x0
   653: .equ	NRWW_STOP_ADDR	= 0x3ff
   654: .equ	RWW_START_ADDR	= 0x0
   655: .equ	RWW_STOP_ADDR	= 0x0
   656: .equ	PAGESIZE	= 16
   657: 
   658: 
   659: 
   660: ; ***** INTERRUPT VECTORS ************************************************
   661: .equ	INT0addr	= 0x0001	; External Interrupt Request 0
   662: .equ	INT1addr	= 0x0002	; External Interrupt Request 1
   663: .equ	ICP1addr	= 0x0003	; Timer/Counter1 Capture Event
   664: .equ	OC1Aaddr	= 0x0004	; Timer/Counter1 Compare Match A
   665: .equ	OC1addr	= 0x0004	; For compatibility
   666: .equ	OVF1addr	= 0x0005	; Timer/Counter1 Overflow
   667: .equ	OVF0addr	= 0x0006	; Timer/Counter0 Overflow
   668: .equ	URXCaddr	= 0x0007	; USART, Rx Complete
   669: .equ	URXC0addr	= 0x0007	; For compatibility
   670: .equ	UDREaddr	= 0x0008	; USART Data Register Empty
   671: .equ	UDRE0addr	= 0x0008	; For compatibility
   672: .equ	UTXCaddr	= 0x0009	; USART, Tx Complete
   673: .equ	UTXC0addr	= 0x0009	; For compatibility
   674: .equ	ACIaddr	= 0x000a	; Analog Comparator
   675: .equ	PCIBaddr	= 0x000b	; Pin Change Interrupt Request B
   676: .equ	PCIaddr	= 0x000b	; For compatibility
   677: .equ	OC1Baddr	= 0x000c	; 
   678: .equ	OC0Aaddr	= 0x000d	; 
   679: .equ	OC0Baddr	= 0x000e	; 
   680: .equ	USI_STARTaddr	= 0x000f	; USI Start Condition
   681: .equ	USI_OVFaddr	= 0x0010	; USI Overflow
   682: .equ	ERDYaddr	= 0x0011	; 
   683: .equ	WDTaddr	= 0x0012	; Watchdog Timer Overflow
   684: .equ	PCIAaddr	= 0x0013	; Pin Change Interrupt Request A
   685: .equ	PCIDaddr	= 0x0014	; Pin Change Interrupt Request D
   686: 
   687: .equ	INT_VECTORS_SIZE	= 21	; size in words
   688: 
   689: #endif  /* _TN2313ADEF_INC_ */
   690: 
   691: ; ***** END OF FILE ******************************************************
   692: 
  Continuing file ish.asm
     2: ; Internal Hardware Init  ======================================
     3: 		.equ 	XTAL = 20000000 	
     4: 		.equ 	baudrate = 19200  
     5: 		.equ 	bauddivider = XTAL/(16*baudrate)-1
     6: 
     7: .def     ThC=R12	;Час Текущий (считанный)
     8: .def     TmC=R11	;Минута Текущая (считанная)
     9: 
    10: .def     Temp=R16
    11: .def     Temp2=R17
    12: .def     CNT=R18
    13: .def     OutByte=R20
    14: .def     OutByte2=R21
    15: 
    16: .equ	SEG7_DDR=DDRB
    17: .equ	SEG7_PORT=PortB
    18: .equ	DS=PB3
    19: .equ	SHcp=PB4
    20: .equ	STcp=PB5
    21: .equ	dot=2
    22: 
    23: .cseg
    24: .org 0
    25: 
    26: 
    27: RESET:	
    28: 000000   ED0F  ldi R16,low(RAMEND) ;инициализация стека
    29: 000001   BF0D  out SPL,R16
    30: 	
    31: 000002   E400  LDI 	R16, low(bauddivider)
    32: 000003   B909  OUT 	UBRRL,R16
    33: 000004   E000  LDI 	R16, high(bauddivider)
    34: 000005   B902  OUT 	UBRRH,R16
    35: 
    36: 000006   E000  LDI 	R16,0
    37: 000007   B90B  OUT 	UCSRA, R16
    38:  
    39: ; Прерывания запрещены, прием-передача разрешен.
    40: 000008   E108  LDI 	R16, (1<<RXEN)|(1<<TXEN)|(0<<RXCIE)|(0<<TXCIE)|(0<<UDRIE)
    41: 000009   B90A  OUT 	UCSRB, R16	
    42: 
    43: ; Формат кадра - 8 бит, пишем в регистр UCSRC, за это отвечает бит селектор
    44: 00000A   E006  LDI 	R16, (1<<UCSZ0)|(1<<UCSZ1)
    45: 00000B   B903  OUT 	UCSRC, R16
    46: 
    47: 00000C   E308  ldi Temp, 1<<DS|1<<SHcp|1<<STcp  ;настройка порта SEG7
    48: 00000D   B317  in Temp2, SEG7_DDR
    49: 00000E   7C17  ANDI Temp2, ~(1<<STcp|1<<SHcp|1<<DS)
    50: 00000F   2B01  OR Temp, Temp2
    51: 000010   BB07  out SEG7_DDR,Temp
    52: 	
    53: 000011   D0A8  Rcall Delay
    54: 000012   C008  RJMP Begin
    55: 
    56: sym_table:
    57: 	; Таблица символов 7SEG индикатора с общим катодом
    58: 	; A = Q5, B = Q7, C = Q1, D = Q3,
    59: 	; E = Q4, F = Q6, G = Q0, dp = Q2,
    60: 
    61: 	.DB 0xFA, 0x82 ; 0, 1
        000013 82FA
    62: 	.DB 0xB9, 0xAB ; 2, 3
        000014 ABB9
    63: 	.DB 0xC3, 0x6B ; 4, 5
        000015 6BC3
    64: 	.DB 0x7B, 0xA2 ; 6, 7
        000016 A27B
    65: 	.DB 0xFB, 0xEB ; 8, 9
        000017 EBFB
    66: 	.DB 0xF3, 0x5B ; A, b
        000018 5BF3
    67: 	.DB 0x78, 0x9B ; C, d
        000019 9B78
    68: 	.DB 0x79, 0x71 ; E, F
        00001A 7179
    69: 
    70: 
    71: 00001B   D188  rcall OWReset
    72: 00001C   EC0C  ldi R16,0xCC
    73: 00001D   D1A3  rcall OWWriteByte
    74: 00001E   EB0E  ldi R16,0xBE
    75: 00001F   D1A1  rcall OWWriteByte
    76: 000020   2700  clr R16
    77: 000021   D1BA  rcall OWReadByte
    78: 000022   2F60  MOV R22,R16
    79: 000023   D1B8  rcall OWReadByte
    80: 000024   2F70  MOV R23,R16
    81: 000025   D17E  rcall OWReset
    82: 000026   D202  rcall t_convert
    83: 000027   2F07  MOV R16,R23
    84: 000028   2F16  MOV R17,R22
    85: 000029   D227  rcall NumToASCII
    86: 00002A   D179  rcall OWReset
    87: 00002B   EC0C  ldi R16,0xCC
    88: 00002C   D194  rcall OWWriteByte
    89: 00002D   E404  ldi R16,0x44
    90: 00002E   D192  rcall OWWriteByte
    91: 00002F   E001  LDI Temp, 1<<PB0
    92: 000030   2EF0  MOV DHTDAT, Temp
    93: 000031   D0EF  Rcall DHT22Read
    94: 000032   D1B2  RCALL DHT22Convert
    95: 000033   E6E4  LDI ZL,Low(HumidTen)
    96: 000034   E0F0  LDI ZH,High(HumidTen)
    97: 000035   E6AF  LDI XL,Low(Humid2Ten)
    98: 000036   E0B0  LDI XH,High(Humid2Ten)
    99: 000037   E018  LDI R17, 8
   100: 000038   9101  LD R16, Z+
   101: 000039   930D  ST X+, R16
   102: 00003A   951A  DEC R17
   103: 00003B   F7E1  BRNE MovDHT
   104: 00003C   E002  LDI Temp, 1<<PB1
   105: 00003D   2EF0  MOV DHTDAT, Temp
   106: 00003E   D0E2  Rcall DHT22Read
   107: 00003F   D1A5  RCALL DHT22Convert
   108: 	
   109: 000040   9100  LDS R16, HumidTen
        000041   0064
   110: 000042   9502  SWAP R16
   111: 000043   2EC0  MOV R12, R16
   112: 000044   9100  LDS R16, HumidInt
        000045   0065
   113: 000046   0EC0  ADD R12, R16
   114: 000047   9100  LDS R16, HumidDec
        000048   0066
   115: 000049   9502  SWAP R16
   116: 00004A   2EB0  MOV R11, R16
   117: 
   118: 00004B   D09D  rcall BCDTo7SEG
   119: 00004C   9100  LDS R16, TimeToOut+2
        00004D   006D
   120: 00004E   9300  STS TimeToOut+3, R16
        00004F   006E
   121: 000050   9100  LDS R16, TimeToOut+1
        000051   006C
   122: 000052   9300  STS TimeToOut+2, R16
        000053   006D
   123: 000054   9100  LDS R16, TimeToOut
        000055   006B
   124: 000056   9300  STS TimeToOut+1, R16
        000057   006C
   125: 000058   2700  CLR R16
   126: 000059   9300  STS TimeToOut, R16
        00005A   006B
   127: 00005B   D05E  rcall Delay
   128: 	
   129: 00005C   9100  LDS R16, Humid2Ten
        00005D   006F
   130: 00005E   9502  SWAP R16
   131: 00005F   2EC0  MOV R12, R16
   132: 000060   9100  LDS R16, Humid2Int
        000061   0070
   133: 000062   0EC0  ADD R12, R16
   134: 000063   9100  LDS R16, Humid2Dec
        000064   0071
   135: 000065   9502  SWAP R16
   136: 000066   2EB0  MOV R11, R16
   137: 
   138: 000067   D081  rcall BCDTo7SEG
   139: 000068   9100  LDS R16, TimeToOut+2
        000069   006D
   140: 00006A   9300  STS TimeToOut+3, R16
        00006B   006E
   141: 00006C   9100  LDS R16, TimeToOut+1
        00006D   006C
   142: 00006E   9300  STS TimeToOut+2, R16
        00006F   006D
   143: 000070   9100  LDS R16, TimeToOut
        000071   006B
   144: 000072   9300  STS TimeToOut+1, R16
        000073   006C
   145: 000074   2700  CLR R16
   146: 000075   9300  STS TimeToOut, R16
        000076   006B
   147: 000077   D042  rcall Delay
   148: 	
   149: 000078   CFA2  RJMP Begin
   150: ;|----------------------------------------------------------------------
   151: ;| Процедура вывода на 7 сегментный индикатор
   152: ;| На входе: разряд в OutByte
   153: ;|           символ в OutByte2
   154: ;|----------------------------------------------------------------------
   155: 000079   B10C  IN R16, UDR
   156: 00007A   3503  CPI R16, 0x53
   157: 00007B   F4E1  BRNE notrcv
   158: uart_sent:
   159: 00007C   E6E4  LDI ZL,Low(HumidTen)
   160: 00007D   E0F0  LDI ZH,High(HumidTen)  ;загрузка начального адреса Влажности
   161: 00007E   D01A  RCALL DHTSend
   162: 00007F   E009  LDI R16, 0x09	;Tab
   163: 000080   D047  rcall uart_snt
   164: 000081   E6EF  LDI ZL,Low(Humid2Ten)
   165: 000082   E0F0  LDI ZH,High(Humid2Ten)  ;загрузка начального адреса Влажности
   166: 000083   D015  RCALL DHTSend
   167: 	
   168: 	
   169: 000084   E009  LDI R16, 0x09	;Tab
   170: 000085   D042  rcall uart_snt
   171: 000086   E7EA  LDI ZL,Low(NumberInASCII)
   172: 000087   E0F0  LDI ZH,High(NumberInASCII)
   173: 000088   9101  LD R16, Z+
   174: 000089   3200  CPI R16, 0x20
   175: 00008A   F009  BREQ PC+1
   176: 00008B   D03C  rcall uart_snt
   177: 00008C   9101  LD R16, Z+
   178: 00008D   3200  CPI R16, 0x20
   179: 00008E   F009  BREQ PC+1
   180: 00008F   D038  rcall uart_snt
   181: 000090   9101  LD R16, Z+
   182: 000091   D036  rcall uart_snt
   183: 000092   9101  LD R16, Z+
   184: 000093   D034  rcall uart_snt
   185: 000094   8100  LD R16, Z
   186: 000095   D032  rcall uart_snt
   187: 000096   E00A  LDI R16, 0x0A	;На новую строку
   188: 000097   D030  rcall uart_snt
   189: 
   190: notrcv:
   191: 000098   9508  RET
   192: 	
   193: DHTSend:
   194: 000099   9101  LD R16, Z+
   195: 00009A   5D00  SUBI R16, (-48)
   196: 00009B   D02C  RCALL uart_snt
   197: 00009C   9101  LD R16, Z+
   198: 00009D   5D00  SUBI R16, (-48)
   199: 00009E   D029  RCALL uart_snt
   200: 00009F   E20E  LDI R16, 0x2E	;Загружаем символ точки
   201: 0000A0   D027  RCALL uart_snt
   202: 0000A1   9101  LD R16, Z+
   203: 0000A2   5D00  SUBI R16, (-48)
   204: 0000A3   D024  RCALL uart_snt
   205: 
   206: 0000A4   E009  LDI R16, 0x09	;Tab
   207: 0000A5   D022  rcall uart_snt
   208: 0000A6   9101  LD R16, Z+
   209: 0000A7   3200  CPI R16, 0x20
   210: 0000A8   F009  BREQ PC+1
   211: 0000A9   D01E  rcall uart_snt
   212: 0000AA   9101  LD R16, Z+
   213: 0000AB   3200  CPI R16, 0x20
   214: 0000AC   F021  BREQ PC+4
   215: 0000AD   F008  BRLO PC+1
   216: 0000AE   C001  RJMP PC+1
   217: 0000AF   5D00  SUBI R16, (-48)
   218: 0000B0   D017  RCALL uart_snt
   219: 0000B1   9101  LD R16, Z+
   220: 0000B2   5D00  SUBI R16, (-48)
   221: 0000B3   D014  RCALL uart_snt
   222: 0000B4   E20E  LDI R16, 0x2E	;Загружаем символ точки
   223: 0000B5   D012  RCALL uart_snt
   224: 0000B6   8100  LD R16, Z
   225: 0000B7   5D00  SUBI R16, (-48)
   226: 0000B8   D00F  RCALL uart_snt
   227: 0000B9   9508  RET
   228: ;|----------------------------------------------------------------------
   229: ;|                               END
   230: ;|----------------------------------------------------------------------
   231: 
   232: 
   233: 0000BA   E000  LDI R16,0;задержка (0,0,24 - 0,5 секунды)
   234: 0000BB   2E30  MOV R3, R16
   235: 0000BC   E10E  LDI R16,30
   236: 0000BD   2E40  MOV R4, R16
   237: 
   238: 0000BE   D04B  rcall TimeToSeg
   239: 0000BF   943A  dec R3
   240: 0000C0   F7E9  brne Loop1
   241: 0000C1   99B6  SBIC PINB, 6
   242: 0000C2   DFB9  RCALL uart_sent
   243: 0000C3   995F  SBIC 	UCSRA, RXC	; Пропуск если нет приёма
   244: 0000C4   DFB4  RCALL	uart_rcv
   245: 0000C5   944A  dec R4
   246: 0000C6   F7B9  brne Loop1
   247: 0000C7   9508  RET
   248: 
   249: ; Процедура отправки байта
   250: 0000C8   9B5D  SBIS 	UCSRA,UDRE	; Пропуск если нет флага готовности
   251: 0000C9   CFFE  RJMP	uart_snt 	; ждем готовности - флага UDRE
   252: 
   253: 0000CA   B90C  OUT	UDR, R16	; шлем байт
   254: 0000CB   9508  RET
   255: 
   256: 
   257: ;|----------------------------------------------------------------------
   258: ;| Процедура вывода на 7 сегментный индикатор
   259: ;| На входе: разряд в OutByte
   260: ;|           символ в OutByte2
   261: ;|----------------------------------------------------------------------
   262: Output:
   263: 0000CC   E020  ldi CNT,0
   264: 0000CD   9488  clc
   265: 0000CE   0F44  lsl OutByte
   266: 0000CF   F018  BRLO One		;переход если С=1
   267: 
   268: 0000D0   E100  ldi Temp, 0<<STcp|1<<SHcp|0<<DS
   269: 0000D1   D009  rcall EndWR
   270: 0000D2   C002  rjmp Check
   271: 
   272: 0000D3   E108  ldi Temp, 0<<STcp|1<<SHcp|1<<DS
   273: 0000D4   D006  rcall EndWR
   274: 
   275: 0000D5   E000  ldi Temp, 0<<STcp|0<<SHcp|0<<DS
   276: 0000D6   D004  rcall EndWR
   277: 
   278: 0000D7   9523  inc CNT
   279: 0000D8   3028  cpi CNT,0b00001000
   280: 0000D9   F031  breq STout
   281: 0000DA   CFF3  rjmp Next
   282: 
   283: 0000DB   B318  in Temp2, SEG7_PORT
   284: 0000DC   7C17  ANDI Temp2, ~(1<<STcp|1<<SHcp|1<<DS)
   285: 0000DD   2B01  OR Temp, Temp2
   286: 0000DE   BB08  out SEG7_PORT,Temp
   287: 0000DF   9508  ret
   288: 
   289: 0000E0   F01E  BRTS STend
   290: 0000E1   9468  SET
   291: 0000E2   2F45  MOV OutByte, OutByte2
   292: 0000E3   CFE8  rjmp Output
   293: 
   294: 0000E4   E200  ldi Temp, 1<<STcp|0<<SHcp|0<<DS	;Затолкали, теперь выводим.
   295: 0000E5   DFF5  rcall EndWR
   296: 0000E6   E000  ldi Temp, 0<<STcp|0<<SHcp|0<<DS
   297: 0000E7   DFF3  rcall EndWR
   298: 0000E8   9508  ret
   299: ;|----------------------------------------------------------------------
   300: ;|                               END
   301: ;|----------------------------------------------------------------------
   302: 
   303: 
   304: ;|----------------------------------------------------------------------
   305: ;| Процедура преобразования BCD времени в символы для 7 сегментного индикатора
   306: ;| На входе: минуты в R11
   307: ;|           часы в R12
   308: ;| На выходе: В TimeToOut - старший разряд часов,
   309: ;| в TimeToOut+1 - младний разряд часов,
   310: ;| в TimeToOut+2 - старший разряд минут,
   311: ;| в TimeToOut+3 - младний разряд минут
   312: ;|----------------------------------------------------------------------
   313: BCDTo7SEG:
   314: 0000E9   930F  PUSH Temp
   315: 0000EA   2D0C  MOV Temp, R12
   316: 0000EB   9502  SWAP Temp	;Поменять местами тетрады
   317: 0000EC   700F  ANDI Temp, 0b00001111
   318: 0000ED   D014  rcall FSym
   319: 0000EE   9300  STS TimeToOut, Temp
        0000EF   006B
   320: 
   321: 0000F0   2D0C  MOV Temp, R12
   322: 0000F1   700F  ANDI Temp, 0b00001111
   323: 0000F2   D00F  rcall FSym
   324: 0000F3   6004  ORI Temp, 1<<dot
   325: 0000F4   9300  STS TimeToOut+1, Temp
        0000F5   006C
   326: 
   327: 0000F6   2D0B  MOV Temp, R11
   328: 0000F7   9502  SWAP Temp	;Поменять местами тетрады
   329: 0000F8   700F  ANDI Temp, 0b00001111
   330: 0000F9   D008  rcall FSym
   331: 0000FA   9300  STS TimeToOut+2, Temp
        0000FB   006D
   332: 
   333: 0000FC   2D0B  MOV Temp, R11
   334: 0000FD   700F  ANDI Temp, 0b00001111
   335: 0000FE   D003  rcall FSym
   336: 0000FF   9300  STS TimeToOut+3, Temp
        000100   006E
   337: 
   338: 000101   C006  rjmp BCDTo7SEGend
   339: 
   340: FSym:	; Загрузить адрес таблицы символов
   341: 000102   E2E6  LDI ZL, LOW (2*sym_table)
   342: 000103   E0F0  LDI ZH, HIGH(2*sym_table)
   343: 	; Найти нужный символ
   344: 000104   0FE0  ADD ZL, Temp
   345: 	; Загрузить данные символа в R0
   346: 000105   95C8  LPM
   347: 000106   2D00  MOV Temp, R0
   348: 000107   9508  ret
   349: 
   350: BCDTo7SEGend:
   351: 000108   910F  POP Temp
   352: 000109   9508  RET
   353: ;|----------------------------------------------------------------------
   354: ;|                               END
   355: ;|----------------------------------------------------------------------
   356: 
   357: ;|----------------------------------------------------------------------
   358: ;| Процедура вывода времени
   359: ;|----------------------------------------------------------------------
   360: TimeToSeg:
   361: 00010A   B70F  IN Temp, SREG
   362: 00010B   930F  Push Temp
   363: 00010C   E6EB  ldi ZL,Low(TimeToOut)
   364: 00010D   E0F0  ldi ZH,High(TimeToOut)  ;загрузка начального адреса массива
   365: 00010E   9151  LD	OutByte2, Z+
   366: 00010F   E042  ldi OutByte, (1<<1) ;Первый символ
   367: 000110   94E8  CLT
   368: 000111   DFBA  rcall Output
   369: 
   370: 000112   9151  LD	OutByte2, Z+
   371: 000113   E044  ldi OutByte, (1<<2) ;Второй символ
   372: 000114   94E8  CLT
   373: 000115   DFB6  rcall Output
   374: 
   375: 000116   9151  LD	OutByte2, Z+
   376: 000117   E048  ldi OutByte, (1<<3) ;Третий символ
   377: 000118   94E8  CLT
   378: 000119   DFB2  rcall Output
   379: 
   380: 00011A   9151  LD	OutByte2, Z+
   381: 00011B   E140  ldi OutByte, (1<<4) ;Четвертый символ
   382: 00011C   94E8  CLT
   383: 00011D   DFAE  rcall Output
   384: 00011E   910F  POP Temp
   385: 00011F   BF0F  OUT SREG, Temp
   386: 000120   9508  RET
   387: ;|----------------------------------------------------------------------
   388: ;|                               END
   389: ;|----------------------------------------------------------------------
   390: .include "dht22-multi.asm"
  Including file dht22-multi.asm
     1: 	.ifndef XTAL
     2: 		.error "XTAL must be defined!"
     3: 	.endif
     4: 
     5: 	.exit XTAL < 4000000	;XTAL слишком мал, возможна большая погрешность
     6: 
     7: 	.equ CYCL_PER_US=(XTAL/1000000)	; количество такотв на микросекунду
     8: 	.equ C4P=(CYCL_PER_US/4)		; 4 такта на одну микросекунду
     9: ;------------------------------------------------------------------------------
    10: ; Начальные установки для реализации протокола DHT22
    11: ;------------------------------------------------------------------------------
    12: 	.equ	DHTPORT	=	PORTB		; Порт МК, где висит DHT22
    13: 	.equ	DHTPIN	=	PINB		; Пин МК, где висит DHT22
    14: 	.equ	DHTDDR	=	DDRB		; DDR МК, где висит DHT22
    15: 	.def	DHTEMP	=	R14			; Временные данные
    16: 	.def	DHTDAT	=	R15			; Ножка порта, где висит DHT22
    17: 	.def	DHTCount =	R16			; Счетчик
    18: 	.def	DHTData0 =	R17			; Байт данных - Контрольная сумма
    19: 	.def	DHTData1 =	R18			; Байт данных - Младший байт температуры	(DHT22TLB)
    20: 	.def	DHTData2 =	R19			; Байт данных - Старший байт температуры	(DHT22TMB)
    21: 	.def	DHTData3 =	R20			; Байт данных - Младший байт влажности		(DHT22RHLB)
    22: 	.def	DHTData4 =	R21			; Байт данных - Старший байт влажности		(DHT22RHMB)
    23: ; ПЕРЕД ВЫЗОВОМ  DHT22Read ПОДОЖДАТЬ 0,5 СЕКУНДЫ!!!
    24: ;------------------------------------------------------------------------------
    25: 	.DSEG
    26: 	DHT22RHLB:	.byte	1
    27: 	DHT22RHMB:	.byte	1
    28: 	DHT22TLB:	.byte	1
    29: 	DHT22TMB:	.byte	1
    30: 	.CSEG
    31: DHT22Read:
    32: 000121   930F  PUSH DHTCount
    33: 000122   B70F  IN DHTCount, SREG
    34: 000123   94F8  CLI				;Запрещаем прерывания
    35: 000124   930F  PUSH DHTCount
    36: 000125   931F  PUSH DHTData0	;Сохраним содержимое регистров
    37: 000126   932F  PUSH DHTData1
    38: 000127   933F  PUSH DHTData2
    39: 000128   934F  PUSH DHTData3
    40: 000129   935F  PUSH DHTData4
    41: 00012A   94E8  CLT							;Очищаем флаг Т
    42: 00012B   B2E8  IN DHTEMP, DHTPORT
    43: 00012C   28EF  OR DHTEMP, DHTDAT
    44: 00012D   BAE8  OUT DHTPORT, DHTEMP
    45: ;	SBI DHTPORT, DHTDAT
    46: 00012E   B2E7  IN DHTEMP, DHTDDR
    47: 00012F   28EF  OR DHTEMP, DHTDAT
    48: 000130   BAE7  OUT DHTDDR, DHTEMP
    49: ;	SBI DHTDDR, DHTDAT
    50: 	;/////// Start ///////
    51: 000131   B2E8  IN DHTEMP, DHTPORT
    52: 000132   94F0  COM DHTDAT
    53: 000133   20EF  AND DHTEMP, DHTDAT
    54: 000134   BAE8  OUT DHTPORT, DHTEMP
    55: ;	CBI DHTPORT, DHTDAT			; ставим линию в 0
    56: 	
    57: 000135   E0B9  LDI		XH, HIGH(C4P*500)	; выжидаем 500 мкс (1/2 от 1мс)
    58: 000136   ECA4  LDI		XL, LOW(C4P*500)
    59: 000137   D05B  RCALL		DelayDHT22
    60: 000138   E0B9  LDI		XH, HIGH(C4P*500)	; выжидаем 500 мкс (необходимое время реакции устройств на сброс)
    61: 000139   ECA4  LDI		XL, LOW(C4P*500)
    62: 00013A   D058  RCALL		DelayDHT22
    63: 00013B   B2E7  IN DHTEMP, DHTDDR
    64: 00013C   20EF  AND DHTEMP, DHTDAT
    65: 00013D   BAE7  OUT DHTDDR, DHTEMP
    66: ;	CBI DHTDDR, DHTDAT			; ставим линию в 1
    67: 00013E   E0B0  LDI		XH, HIGH(C4P*40)	; выжидаем 40 мкс (необходимое  время реакции устройств на сброс)
    68: 00013F   ECA8  LDI		XL, LOW(C4P*40)
    69: 000140   D052  RCALL		DelayDHT22
    70: 
    71: 000141   B2E7  IN DHTEMP, DHTDDR
    72: 000142   20EF  AND DHTEMP, DHTDAT
    73: 000143   BAE7  OUT DHTDDR, DHTEMP
    74: ;	CBI DHTDDR, DHTDAT			;переключаем на вход
    75: 000144   B2E8  IN DHTEMP, DHTPORT
    76: 000145   20EF  AND DHTEMP, DHTDAT
    77: 000146   BAE8  OUT DHTPORT, DHTEMP
    78: ;	CBI DHTPORT, DHTDAT
    79: 000147   E0B0  LDI		XH, HIGH(C4P*50)	; выжидаем 60 мкс (сенсор прижимает линию в 0 80 мкс)
    80: 000148   EFAA  LDI		XL, LOW(C4P*50)
    81: 000149   D049  RCALL		DelayDHT22
    82: 	
    83: 00014A   94F0  COM DHTDAT
    84: 00014B   B2E6  IN DHTEMP, DHTPIN
    85: 00014C   20EF  AND DHTEMP, DHTDAT
    86: 00014D   F009  BREQ DHTskip1
    87: ;	SBIC DHTPIN, DHTDAT
    88: 00014E   C038  RJMP DHT22ReadError			; Если 1, то датчик не ответил
    89: 
    90: DHTskip1:
    91: 00014F   E0B1  LDI		XH, HIGH(C4P*60)	; выжидаем 80 мкс (сенсор прижимает линию в 1 80 мкс)
    92: 000150   E2AC  LDI		XL, LOW(C4P*60)
    93: 000151   D041  RCALL		DelayDHT22
    94: 	
    95: 000152   B2E6  IN DHTEMP, DHTPIN
    96: 000153   20EF  AND DHTEMP, DHTDAT
    97: 000154   F409  BRNE WaitZero
    98: ;	SBIS DHTPIN, DHTDAT
    99: 000155   C031  RJMP DHT22ReadError			; Если 0, то датчик не ответил
   100: WaitZero:
   101: 000156   B2E6  IN DHTEMP, DHTPIN
   102: 000157   20EF  AND DHTEMP, DHTDAT
   103: 000158   F009  BREQ DHTskip2
   104: ;	SBIC DHTPIN, DHTDAT			; ждем 0 (начала передачи данных)
   105: 000159   CFFC  RJMP WaitZero
   106: 
   107: 	;///////// Передача данных /////////////
   108: DHTskip2:
   109: 00015A   2711  CLR DHTData0
   110: 00015B   2722  CLR DHTData1
   111: 00015C   2733  CLR DHTData2
   112: 00015D   2744  CLR DHTData3
   113: 00015E   2755  CLR DHTData4
   114: 00015F   E208  LDI DHTCount, 40
   115: ReadDhtBit:
   116: 000160   B2E6  IN DHTEMP, DHTPIN
   117: 000161   20EF  AND DHTEMP, DHTDAT
   118: 000162   F409  BRNE DHTskip3
   119: ;	SBIS DHTPIN, DHTDAT			; ждем 1 (начало бита)
   120: 000163   CFFC  RJMP ReadDhtBit
   121: DHTskip3:
   122: 000164   E0B0  LDI		XH, HIGH(C4P*50)	; выжидаем 50 мкс (передача 0 длится 26-28мкс, затем пауза 50мкс. )
   123: 000165   EFAA  LDI		XL, LOW(C4P*50)		; выжидаем 50 мкс (передача 1 длится    70мкс, затем пауза 50мкс. )
   124: 000166   D02C  RCALL		DelayDHT22
   125: 
   126: 000167   B2E6  IN DHTEMP, DHTPIN
   127: 000168   20EF  AND DHTEMP, DHTDAT
   128: 000169   F409  BRNE WaitZero2
   129: ;	SBIS DHTPIN, DHTDAT			; Если ещё 1 - значит отправлено 1
   130: 00016A   C006  RJMP DhtReadZero			; А Если уже 0 - значит отправлен 0
   131: WaitZero2:
   132: 00016B   B2E6  IN DHTEMP, DHTPIN
   133: 00016C   20EF  AND DHTEMP, DHTDAT
   134: 00016D   F009  BREQ DHTskip4
   135: ;	SBIC DHTPIN, DHTDAT			; Сразу дождемся 0
   136: 00016E   CFFC  RJMP WaitZero2
   137: DHTskip4:
   138: 00016F   9408  SEC
   139: 000170   C001  RJMP DhtWrBit
   140: 
   141: 000171   9488  CLC
   142: 
   143: DhtWrBit:				; Записываем полученный бит
   144: 000172   1F11  ROL DHTData0
   145: 000173   1F22  ROL DHTData1
   146: 000174   1F33  ROL DHTData2
   147: 000175   1F44  ROL DHTData3
   148: 000176   1F55  ROL DHTData4
   149: 000177   950A  DEC DHTCount
   150: 000178   F739  BRNE ReadDhtBit
   151: 
   152: 000179   1B12  SUB DHTData0, DHTData1	;Проверка контрольной суммы
   153: 00017A   1B13  SUB DHTData0, DHTData2
   154: 00017B   1B14  SUB DHTData0, DHTData3
   155: 00017C   1B15  SUB DHTData0, DHTData4
   156: 00017D   F449  BRNE DHT22ReadError		;Если не 0, значит контрольная сумма не сошлась
   157: 
   158: 00017E   9340  STS DHT22RHLB, DHTData3
        00017F   0060
   159: 000180   9350  STS DHT22RHMB, DHTData4
        000181   0061
   160: 000182   9320  STS DHT22TLB, DHTData1
        000183   0062
   161: 000184   9330  STS DHT22TMB, DHTData2
        000185   0063
   162: 000186   C001  RJMP DHT22ReadOut
   163: 
   164: DHT22ReadError:
   165: 000187   9468  SET
   166: 
   167: 000188   915F  POP DHTData4	;Вернём содержимое регистров
   168: 000189   914F  POP DHTData3	
   169: 00018A   913F  POP DHTData2
   170: 00018B   912F  POP DHTData1
   171: 00018C   911F  POP DHTData0
   172: 00018D   910F  POP DHTCount
   173: 00018E   F416  BRTC PC+2
   174: 00018F   6400  ORI DHTCount, 1<<6
   175: 000190   BF0F  OUT SREG, DHTCount
   176: 000191   910F  POP DHTCount
   177: 000192   9508  RET
   178: ;-----------------------------------------------------------------------
   179: ;   END
   180: ;-----------------------------------------------------------------------
   181: 
   182: DelayDHT22:
   183: 000193   9711  SBIW	XH:XL, 1			; 2 такта
   184: 000194   F7F1  BRNE	DelayDHT22		; 1/2
   185: 000195   9508  RET							; 4
  Continuing file ish.asm
   391: .include "1-wire.asm"
  Including file 1-wire.asm
     1: ;------------------------------------------------------------------------------
     2: ; http://avr-mcu.dxp.pl
     3: ; (c) Radoslaw Kwiecien, 2008
     4: ; 
     5: ; Перевод StarXXX, http://hardisoft.ru, 2009
     6: ;------------------------------------------------------------------------------
     7: 
     8: 
     9: 
    10: ;------------------------------------------------------------------------------
    11: ; Начальные установки для реализации протокола 1-Wire
    12: ;------------------------------------------------------------------------------
    13: .equ	OW_PORT	= PORTB				; Порт МК, где висит 1-Wire
    14: .equ	OW_PIN	= PINB				; Порт МК, где висит 1-Wire
    15: .equ	OW_DDR	= DDRB				; Порт МК, где висит 1-Wire
    16: .equ	OW_DQ	= PB2				; Ножка порта, где висит 1-Wire
    17: 
    18: .def	OWCount = r17				; Счетчик
    19: ;------------------------------------------------------------------------------
    20: 
    21: 
    22: ;.cseg
    23: 
    24: .include 	"wait.asm"			; Подключаем модуль временных задержек
  Including file wait.asm
     1: ;------------------------------------------------------------------------------
     2: ; Busy-wait loops utilities module
     3: ; For F_CPU >= 4MHz
     4: ; http://avr-mcu.dxp.pl
     5: ; (c) Radoslaw Kwiecien, 2008
     6: ; 
     7: ; Перевод StarXXX, http://hardisoft.ru, 2009
     8: ;------------------------------------------------------------------------------
     9: 
    10: ;------------------------------------------------------------------------------
    11: ; Модуль временных задержек
    12: ;
    13: ; !!! Для работы модуля необходимо объявить константу F_CPU равную тактовой частоте в герцах !!!
    14: ;
    15: ; !!! задержки действительны для тактовой частоты >= 4 МГц !!!
    16: 
    17: 
    18: ; задержки приблизительны! Чем больше задержка, тем точнее,
    19: ; т.е. при частоте 4МГц задержка в 1 микросекунду, учитывая время вызова подпрограммы и возврата из нее составит 2,5 микросекунды
    20: ; задержка в 10 микросекунд составит 11,5 микросекунд
    21: ; задержка в 100 мкс на самом деле будет 101,5 мкс
    22: ; тоесть, к каждой задержке добавится 1,5 мкс - это время на вызов подпрограммы и на выход из нее
    23: ;------------------------------------------------------------------------------
    24: 
    25: 
    26: 
    27: .ifndef XTAL
    28: 	.error "XTAL must be defined!"
    29: .endif
    30: 
    31: 
    32: .exit XTAL < 4000000	;XTAL too low, possible wrong delay
    33: 
    34: .equ CYCLES_PER_US=(XTAL/1000000)	; количество такотв на микросекунду
    35: .equ C4PUS=(CYCLES_PER_US/4)		; 4 такта на одну микросекунду
    36: ;.equ DVUS(x)=(C4PUS*x)		; вычисляет величину для указанного времени в микросекундах, которую нужно передать Wait4xCycles чтобы получить желаемую задержку
    37: 
    38: ;--------------------------------------------------------------------------------------------------------------
    39: ; Подпрограмма задержки. В цикле отъедается 4 такта на каждую итерацию, кроме последней. В последней - 3 такта.
    40: ; Итого, для получения нужной задержки в микросекундах надо вызывать эту функцию предварительно
    41: ; обработав параметр макросом DVUS:
    42: ;	ldi    XH, HIGH(DVUS(500))
    43: ; 	ldi    XL, LOW(DVUS(500))
    44: ; 	rcall  Wait4xCycles ; пауза 500 микросекунд
    45: ;--------------------------------------------------------------------------------------------------------------
    46: ; Input : XH:XL - number of CPU cycles to wait (divided by four)
    47: ;--------------------------------------------------------------------------------------------------------------
    48: Wait4xCycles:
    49: 000196   9711  sbiw	XH:XL, 1			; 2 такта
    50: 000197   F7F1  brne	Wait4xCycles		; 1/2
    51: 000198   9508  ret							; 4
    52: 
    53: 
    54: ;------------------------------------------------------------------------------
    55: ; Подпрограмма генерирует необходимую задержку в милисекундах
    56: ; На входе: r16 = количество милисекунд
    57: ;------------------------------------------------------------------------------
    58: ; Input : r16 - number of miliseconds to wait
    59: ;------------------------------------------------------------------------------
    60: WaitMiliseconds:
    61: 000199   930F  push 	r16
    62: WaitMsLoop: 
    63: 00019A   E0B9  ldi    XH,HIGH(C4PUS*500)
    64: 00019B   ECA4  ldi    XL,LOW(C4PUS*500)
    65: 00019C   DFF9  rcall  Wait4xCycles
    66: 00019D   E0B9  ldi    XH,HIGH(C4PUS*500)
    67: 00019E   ECA4  ldi    XL,LOW(C4PUS*500)
    68: 00019F   DFF6  rcall  Wait4xCycles
    69: 0001A0   950A  dec    r16
    70: 0001A1   F7C1  brne   WaitMsLoop
    71: 0001A2   910F  pop    r16
    72: 0001A3   9508  ret
    73: ;------------------------------------------------------------------------------
    74: ; End of file
    75: ;------------------------------------------------------------------------------
  Continuing file 1-wire.asm
    25: 
    26: 
    27: ;------------------------------------------------------------------------------
    28: ; СБРОС
    29: ; Каждая передача по протоколу 1-Wire начинается с сигнала Reset.
    30: ; После вызова этой процедуры в флаге Т регистра SGER содержится бит 
    31: ; присутствия: 1 - если на шине нет устройств, 0 - если есть
    32: ;------------------------------------------------------------------------------
    33: ; Output : T - presence bit
    34: ;------------------------------------------------------------------------------
    35: OWReset:
    36: 0001A4   98C2  cbi		OW_PORT,OW_DQ		; Выводим в порт 0
    37: 0001A5   9ABA  sbi		OW_DDR,OW_DQ		; Переключаем порт на вывод
    38: 
    39: 0001A6   E0B9  ldi		XH, HIGH(C4PUS*470)	; Ждем 470 микросекунд при придавленной в 0 линии. Это и есть импульс сброса.
    40: 0001A7   E2AE  ldi		XL, LOW(C4PUS*470)
    41: 0001A8   DFED  rcall		Wait4xCycles
    42: 	
    43: 0001A9   98BA  cbi		OW_DDR,OW_DQ		; Переключаем порт на ввод
    44: 
    45: 0001AA   E0B1  ldi		XH, HIGH(C4PUS*70)	; выжидаем 70 мкс (необходимое минимальное время реакции устройств на сброс)
    46: 0001AB   E5AE  ldi		XL, LOW(C4PUS*70)
    47: 0001AC   DFE9  rcall		Wait4xCycles
    48: 
    49: 0001AD   9468  set							; Устанавливаем флаг Т в 1
    50: 0001AE   9BB2  sbis	OW_PIN,OW_DQ		; Если на линии после паузы осталась 1, значит устройств 1-Wire на ней нет. Пропускаем след. команду
    51: 0001AF   94E8  clt							; Линия была в 0 - значит на ней кто-то есть, и ответил нам импульсом PRESENCE
    52: 
    53: 0001B0   E0B4  ldi		XH, HIGH(C4PUS*240)	; Пауза 240 мкс после сброса
    54: 0001B1   EBA0  ldi		XL, LOW(C4PUS*240)
    55: 0001B2   DFE3  rcall		Wait4xCycles
    56: 
    57: 0001B3   9508  ret
    58: 
    59: 
    60: ;------------------------------------------------------------------------------
    61: ; ОТПРАВКА 1 БИТА
    62: ; Эта процедура отправляет 1 бит в линию 1-Wire.
    63: ; Отправляемый бит должен быть помещен в флаг С статусного регистра
    64: ;------------------------------------------------------------------------------
    65: ; Input : C - bit to write
    66: ;------------------------------------------------------------------------------
    67: OWWriteBit:
    68: 0001B4   F418  brcc	OWWriteZero			; Если флаг С = 0, то переход на OWWriteZero
    69: 0001B5   E0B0  ldi		XH, HIGH(C4PUS*1)	; Для посылки 1 линию нужно придавить в 0 всего на 1 мкс
    70: 0001B6   E0A5  ldi		XL, LOW(C4PUS*1)
    71: 0001B7   C002  rjmp	OWWriteOne			; переходим к отправке
    72: OWWriteZero:	
    73: 0001B8   E0B2  ldi		XH, HIGH(C4PUS*120)	; Для посылки 0 линию нужно придавить в 0 на 120 мкс
    74: 0001B9   E5A8  ldi		XL, LOW(C4PUS*120)
    75: OWWriteOne:
    76: 0001BA   9ABA  sbi		OW_DDR, OW_DQ		; Переводим порт на выход, а там уже был 0, соответственно и линия придавливается в 0
    77: 0001BB   DFDA  rcall	Wait4xCycles		; ждем
    78: 0001BC   98BA  cbi		OW_DDR, OW_DQ		; Переводим порт на вход
    79: 	
    80: 0001BD   E0B1  ldi		XH, HIGH(C4PUS*60)	; Должна быть пауза между таймслотами, вообще-то от 1 мкс, но здесь сделали 60 мкс
    81: 0001BE   E2AC  ldi		XL, LOW(C4PUS*60)
    82: 0001BF   DFD6  rcall	Wait4xCycles
    83: 0001C0   9508  ret
    84: 
    85: 
    86: ;------------------------------------------------------------------------------
    87: ; ОТПРАВКА 1 БАЙТА
    88: ; Эта процедура отправляет 1 байт в линию 1-Wire.
    89: ; Отправляемый байт должен быть помещен в регистр r16
    90: ;------------------------------------------------------------------------------
    91: ; Input : r16 - byte to write
    92: ;------------------------------------------------------------------------------
    93: OWWriteByte:
    94: 0001C1   931F  push	OWCount			; Сохраняем регистр счетчика
    95: 0001C2   E010  ldi		OWCount,0		; Взводим в нём нолик
    96: 
    97: OWWriteLoop:				
    98: 0001C3   9507  ror		r16				; Сдвигаем байт вправо через флаг C
    99: 0001C4   DFEF  rcall	OWWriteBit		; отправляем в линию
   100: 0001C5   9513  inc		OWCount			; увеличиваем счетчик
   101: 0001C6   3018  cpi		OWCount,8		; проверяем на 8
   102: 0001C7   F7D9  brne	OWWriteLoop		; если меньше - следующий бит
   103: 0001C8   911F  pop		OWCount			; восстанавливаем регистр-счетчик
   104: 0001C9   9508  ret
   105: 
   106: 
   107: 
   108: ;------------------------------------------------------------------------------
   109: ; ЧТЕНИЕ 1 БИТА
   110: ; Эта процедура читает 1 бит из линии 1-Wire.
   111: ; Принятый бит помещается в флаг С статусного регистра
   112: ;------------------------------------------------------------------------------
   113: ; Output : C - bit from slave
   114: ;------------------------------------------------------------------------------
   115: OWReadBit:
   116: 0001CA   E0B0  ldi		XH, HIGH(C4PUS*1)	; Придавливаем линию в 0 на 1 мкс
   117: 0001CB   E0A5  ldi		XL, LOW(C4PUS*1)
   118: 0001CC   9ABA  sbi		OW_DDR, OW_DQ
   119: 0001CD   DFC8  rcall	Wait4xCycles
   120: 
   121: 0001CE   98BA  cbi		OW_DDR, OW_DQ		; Переводим порт на чтение
   122: 0001CF   E0B0  ldi		XH, HIGH(C4PUS*5)	; ждем 5 мкс
   123: 0001D0   E1A9  ldi		XL, LOW(C4PUS*5)
   124: 0001D1   DFC4  rcall	Wait4xCycles
   125: 
   126: 0001D2   94E8  clt							; Сбрасываем флаг Т
   127: 0001D3   99B2  sbic	OW_PIN,OW_DQ		; Если на линии 0 - то пропускаем следующую команду
   128: 0001D4   9468  set
   129: 
   130: 								; Итак, сейчас в регистре Т полученный бит
   131: 
   132: 0001D5   E0B0  ldi		XH, HIGH(C4PUS*50)	; выжидаем 50 мкс для окончания таймслота
   133: 0001D6   EFAA  ldi		XL, LOW(C4PUS*50)
   134: 0001D7   DFBE  rcall	Wait4xCycles
   135: 								; переносим флаг Т в флаг С
   136: 0001D8   9408  sec
   137: 0001D9   F00E  brts	OWReadBitEnd
   138: 0001DA   9488  clc
   139: 
   140: OWReadBitEnd:
   141: 0001DB   9508  ret
   142: 
   143: 
   144: 
   145: ;------------------------------------------------------------------------------
   146: ; ЧТЕНИЕ 1 БАЙТА
   147: ; Эта процедура читает 1 байт из линии 1-Wire.
   148: ; Принятый байт помещается регистр r16
   149: ;------------------------------------------------------------------------------
   150: ; Output : r16 - byte from slave
   151: ;------------------------------------------------------------------------------
   152: OWReadByte:
   153: 0001DC   931F  push	OWCount			; Сохраняем регистр-счетчик
   154: 0001DD   E010  ldi		OWCount,0		; и обнуляем его
   155: OWReadLoop:
   156: 0001DE   DFEB  rcall	OWReadBit		; читаем бит
   157: 0001DF   9507  ror		r16				; запихиваем его в r16 сдвигом вправо из флага С
   158: 0001E0   9513  inc		OWCount			; увеличиваем счетчик
   159: 0001E1   3018  cpi		OWCount,8		; уже 8?
   160: 0001E2   F7D9  brne	OWReadLoop		; нет - продолжаем считывать
   161: 0001E3   911F  pop		OWCount			; восстанавливаем регистр-счетчик
   162: 0001E4   9508  ret
   163: ;------------------------------------------------------------------------------
   164: ;
   165: ;------------------------------------------------------------------------------
   166: 
   167: 
   168: 
   169: 
   170: 
   171: ;.include 	"1-Wire Search.asm"		; Подключаем модуль поиска устройств на шине 1-Wire
   172: 
   173: 
   174: 
   175: 
  Continuing file ish.asm
   392: ;|---------------------------------------------------------------------------
   393: ;| Процедура разбивки байта на десятичные разряды
   394: ;| Также если 7й бит R16 = 1, то выводится знак "-"
   395: ;| На входе: целая часть в R16
   396: ;|         дробная часть в R17
   397: ;| На выходе: В NumberInASCII - старший разряд или "-",
   398: ;| в NumberInASCII+1 - средний разряд или "-",
   399: ;| в NumberInASCII+2 - младший разряд
   400: ;| в NumberInASCII+3 - символ точки
   401: ;| в NumberInASCII+4 - дробная часть
   402: ;| Также используется флаг Т
   403: ;|---------------------------------------------------------------------------
   404: 0001E5   930F  PUSH R16
   405: 0001E6   931F  PUSH R17
   406: 0001E7   932F  PUSH R18
   407: 0001E8   933F  PUSH R19
   408: 0001E9   934F  PUSH R20
   409: 0001EA   2722  CLR R18
   410: 0001EB   2733  CLR R19
   411: 0001EC   2744  CLR R20
   412: 0001ED   94E8  CLT
   413: 0001EE   9100  LDS R16, DHT22RHMB
        0001EF   0061
   414: 0001F0   9110  LDS R17, DHT22RHLB
        0001F1   0060
   415: 0001F2   3614  CPI R17,100
   416: 0001F3   0703  CPC R16, R19
   417: 0001F4   F020  BRLO DHTless100
   418: 0001F5   9523  INC R18
   419: 0001F6   5614  SUBI R17, 100
   420: 0001F7   4000  SBCI R16, 0
   421: 0001F8   CFF9  RJMP DHTmore100
   422: 
   423: 0001F9   301A  CPI R17,10
   424: 0001FA   F018  BRLO DHTless10
   425: 0001FB   9503  INC R16
   426: 0001FC   501A  SUBI R17, 10
   427: 0001FD   CFFB  RJMP DHTless100
   428: 
   429: 0001FE   F08E  BRTS DHTsaveT
   430: 0001FF   9320  STS HumidTen, R18
        000200   0064
   431: 000201   9300  STS HumidInt, R16
        000202   0065
   432: 000203   9310  STS HumidDec, R17
        000204   0066
   433: 000205   9468  SET 
   434: 000206   2722  CLR R18
   435: 000207   9100  LDS R16, DHT22TMB
        000208   0063
   436: 000209   9110  LDS R17, DHT22TLB
        00020A   0062
   437: 00020B   FF07  SBRS R16, 7
   438: 00020C   CFE5  RJMP DHTmore100
   439: 	;Флаг и удаление минуса
   440: 00020D   E042  LDI R20, 1<<1
   441: 00020E   770F  ANDI R16, ~(1<<7)
   442: 00020F   CFE2  RJMP DHTmore100
   443: 000210   E230  LDI R19, 0x20
   444: 000211   2322  TST R18
   445: 000212   F409  BRNE SignWR
   446: 000213   E220  LDI R18, 0x20
   447: 000214   2344  TST R20
   448: 000215   F029  BREQ DHTwrT
   449: 000216   3220  CPI R18, 0x20
   450: 000217   F011  BREQ Dhtbr
   451: 000218   E23D  LDI R19, 0x2D
   452: 000219   C001  RJMP DHTwrT
   453: 00021A   E22D  LDI R18, 0x2D
   454: 
   455: DHTwrT:
   456: 00021B   9330  STS TermSign, R19
        00021C   0067
   457: 00021D   9320  STS TermTen, R18
        00021E   0068
   458: 00021F   9300  STS TermInt, R16
        000220   0069
   459: 000221   9310  STS TermDec, R17
        000222   006A
   460: 000223   914F  POP R20
   461: 000224   913F  POP R19
   462: 000225   912F  POP R18
   463: 000226   911F  POP R17
   464: 000227   910F  POP R16
   465: 000228   9508  RET
   466: ;|---------------------------------------------------------------------------
   467: ;|                               END
   468: ;|---------------------------------------------------------------------------
   469: 
   470: ;|---------------------------------------------------------------------------
   471: ;| Процедура преобразования температуры
   472: ;| На входе: Младший байт в R22, Старший байт в R23
   473: ;| На выходе: дробная часть в R22, Целая часть со знаком в R23
   474: ;|---------------------------------------------------------------------------
   475: 000229   930F  PUSH R16
   476: 00022A   931F  PUSH R17
   477: 00022B   FF77  SBRS R23,7	;Если число положительное, то переходим к преобразованию дробной части
   478: 00022C   C007  rjmp IfPositiv
   479: 00022D   2700  CLR R16
   480: 00022E   2711  CLR R17
   481: 00022F   1B06  SUB R16, R22	;Переводим из дополнительного кода
   482: 000230   0B17  SBC R17, R23
   483: 000231   2F60  MOV R22, R16
   484: 000232   2F71  MOV R23, R17
   485: 000233   6078  ORI R23,1<<3	;ставим знак "-"
   486: 
   487: IfPositiv:
   488: 000234   2F06  mov R16, R22
   489: 000235   9506  lsr R16
   490: 000236   9506  lsr R16
   491: 000237   9506  lsr R16
   492: 000238   9506  lsr R16
   493: 000239   0F77  lsl R23
   494: 00023A   0F77  lsl R23
   495: 00023B   0F77  lsl R23
   496: 00023C   0F77  lsl R23
   497: 00023D   2B70  OR R23,R16	;Склеиваем целые части младшего и старшего байтов в один байт
   498: 
   499: 00023E   706F  ANDI R22,0b00001111	;Преобразуем дробную часть
   500: 00023F   2F06  mov R16, R22	;Нужно умножить на 10, для этого:
   501: 000240   0F00  lsl R16		;Умножаем на 2
   502: 000241   0F66  lsl R22
   503: 000242   0F66  lsl R22
   504: 000243   0F66  lsl R22		;Умножаем на 8
   505: 000244   0F60  ADD R22,R16	;Складываем и умножение на 10 готово
   506: 000245   9566  lsr R22
   507: 000246   9566  lsr R22
   508: 000247   9566  lsr R22
   509: 000248   9566  lsr R22		;Делим на 16
   510: 000249   3870  CPI R23, 1<<7	;Проверка на -0, если -0.0 надо убрать минус
   511: 00024A   F419  BRNE end_t_convert
   512: 00024B   2366  TST R22		;Проверка на -0.0
   513: 00024C   F409  BRNE end_t_convert
   514: 00024D   2777  CLR R23
   515: 
   516: end_t_convert:
   517: 00024E   911F  POP R17
   518: 00024F   910F  POP R16
   519: 000250   9508  RET
   520: ;|---------------------------------------------------------------------------
   521: ;|                               END
   522: ;|---------------------------------------------------------------------------
   523: 
   524: ;|---------------------------------------------------------------------------
   525: ;| Процедура разбивки байта на десятичные разряды с преобразованием в ASCII
   526: ;| Также если 7й бит R16 = 1, то выводится знак "-"
   527: ;| На входе: целая часть в R16
   528: ;|         дробная часть в R17
   529: ;| На выходе: В NumberInASCII - старший разряд или "-",
   530: ;| в NumberInASCII+1 - средний разряд или "-",
   531: ;| в NumberInASCII+2 - младший разряд
   532: ;| в NumberInASCII+3 - символ точки
   533: ;| в NumberInASCII+4 - дробная часть
   534: ;| Также используется флаг Т
   535: ;|---------------------------------------------------------------------------
   536: 000251   94E8  CLT		;сбрасываем флаг T
   537: 000252   930F  PUSH R16
   538: 000253   932F  PUSH R18
   539: 000254   931F  PUSH R17
   540: 000255   2711  CLR R17
   541: 000256   2722  CLR R18
   542: 000257   FF07  SBRS R16,7	;Если число положительное, то переходим к преобразованию
   543: 000258   C002  rjmp not_neg
   544: 000259   9468  SET		; Число отрицательное, ставим флаг Т
   545: 00025A   770F  ANDI R16, 0b01111111	; Убираем из числа знак -
   546: 00025B   3604  CPI R16, 100
   547: 00025C   F018  BRLO LoTh100 ;если меньше 100
   548: 00025D   5604  SUBI R16, 100
   549: 00025E   9523  INC R18
   550: 00025F   CFFB  RJMP not_neg
   551: 
   552: 
   553: 000260   2322  TST R18
   554: 000261   F431  BRNE R1NZ ; Разряд 1 не ноль
   555: 000262   6012  ORI R17, 1<<1; Запоминаем что старший разряд "Пробел", вдруг пригодится :-)
   556: 000263   E220  LDI R18, 0x20	;Загружаем символ пробела
   557: 000264   9320  STS NumberInASCII, R18
        000265   007A
   558: 000266   2722  CLR R18
   559: 000267   C004  RJMP CalcDec
   560: 
   561: 000268   5D20  SUBI R18, (-48)	; Прибавляем 48 для получения символа
   562: 000269   9320  STS NumberInASCII, R18
        00026A   007A
   563: 00026B   2722  CLR R18
   564: 
   565: 00026C   300A  CPI R16, 10	;Считаем десятки
   566: 00026D   F018  BRLO LoTh10 ;если меньше 10
   567: 00026E   500A  SUBI R16, 10
   568: 00026F   9523  INC R18
   569: 000270   CFFB  RJMP CalcDec
   570: 
   571: 000271   2322  TST R18
   572: 000272   F441  BRNE R2NZ ; Разряд 2 не ноль
   573: 000273   FF11  SBRS R17,1	;Если первый регистр не 0, тогда записываем 0 а не пробел
   574: 000274   C006  rjmp R2NZ
   575: 
   576: 000275   6011  ORI R17, 1<<0; Запоминаем что средний разряд =0, вдруг пригодится :-)
   577: 000276   E220  LDI R18, 0x20	;Загружаем символ пробела
   578: 000277   9320  STS NumberInASCII+1, R18
        000278   007B
   579: 000279   2722  CLR R18
   580: 00027A   C004  RJMP CalcOne
   581: 
   582: 00027B   5D20  SUBI R18, (-48)	; Прибавляем 48 для получения символа
   583: 00027C   9320  STS NumberInASCII+1, R18
        00027D   007B
   584: 00027E   2722  CLR R18
   585: 
   586: 00027F   5D00  SUBI R16, (-48)	; Прибавляем 48 для получения символа
   587: 000280   9300  STS NumberInASCII+2, R16
        000281   007C
   588: 
   589: 000282   F45E  BRTC EndNTA	;Проверка на -, если минуса нет - заканчиваем
   590: 000283   FF10  SBRS R17,0	;Если второй разряд не 0, тогда записываем 0 а не пробел
   591: 000284   C005  rjmp R1IsZ
   592: 
   593: 000285   94E8  CLT
   594: 000286   E22D  LDI R18, 0x2D	;Загружаем символ минуса
   595: 000287   9320  STS NumberInASCII+1, R18	; пишем минус во второй разряд
        000288   007B
   596: 000289   C004  RJMP EndNTA
   597: 
   598: 
   599: 00028A   94E8  CLT
   600: 00028B   E22D  LDI R18, 0x2D	;Загружаем символ минуса
   601: 00028C   9320  STS NumberInASCII, R18	;В первый разряд
        00028D   007A
   602: 
   603: EndNTA:
   604: 
   605: 00028E   911F  POP R17	;Вывод дробной части
   606: 00028F   E22E  LDI R18, 0x2E	;Загружаем символ точки
   607: 000290   9320  STS NumberInASCII+3, R18	; пишем минус во второй разряд
        000291   007D
   608: 000292   5D10  SUBI R17, (-48)	; Прибавляем 48 для получения символа
   609: 000293   9310  STS NumberInASCII+4, R17
        000294   007E
   610: 
   611: 
   612: 
   613: 
   614: 000295   912F  POP R18
   615: 000296   910F  POP R16
   616: 000297   9508  RET
   617: ;|---------------------------------------------------------------------------
   618: ;|                               END
   619: ;|---------------------------------------------------------------------------
   620: 
   621: .DSEG
   622: HumidTen:	.byte	1
   623: HumidInt:	.byte	1
   624: HumidDec:	.byte	1
   625: TermSign:	.byte	1
   626: TermTen:	.byte	1
   627: TermInt:	.byte	1
   628: TermDec:	.byte	1
   629: TimeToOut:	.byte	4
   630: 
   631: Humid2Ten:	.byte	1
   632: Humid2Int:	.byte	1
   633: Humid2Dec:	.byte	1
   634: Term2Sign:	.byte	1
   635: Term2Ten:	.byte	1
   636: Term2Int:	.byte	1
   637: Term2Dec:	.byte	1
   638: Time2ToOut:	.byte	4
   639: 
   640: 
   641: NumberInASCII:	.byte	5
 -> Warning 011: C-style instructions in file, lines ignored!
 -> Warning 001: 9 symbol(s) defined, but not used!

Program             :      656 words.
Constants           :        8 words.
Total program memory:      664 words.
Eeprom space        :        0 bytes.
Data segment        :       31 bytes.
Compilation completed, no errors.
Compilation endet 20.03.2015, 14:46:20
